// Real-time Market Data Hook using Enhanced WebSocket Service\n// FRONT-003: Real-time Market Data Enhancement\n\nimport { useState, useEffect, useCallback, useRef } from 'react'\nimport { enhancedWebSocketService, MarketDataUpdate, OrderBookUpdate, CandlestickData, TechnicalIndicator } from '../services/enhancedWebSocketService'\n\ninterface UseRealTimeMarketDataOptions {\n  symbols: string[]\n  enableOrderBook?: boolean\n  enableCandlesticks?: boolean\n  enableIndicators?: boolean\n  candlestickTimeframe?: string\n  indicators?: string[]\n  autoConnect?: boolean\n}\n\ninterface MarketDataState {\n  marketData: Record<string, MarketDataUpdate>\n  orderBooks: Record<string, OrderBookUpdate>\n  candlesticks: Record<string, CandlestickData[]>\n  indicators: Record<string, TechnicalIndicator[]>\n  isConnected: boolean\n  connectionStatus: 'connecting' | 'connected' | 'disconnected' | 'error'\n  subscriptions: number\n  lastUpdate: Date | null\n  error: string | null\n}\n\ninterface UseRealTimeMarketDataReturn extends MarketDataState {\n  connect: () => Promise<void>\n  disconnect: () => void\n  subscribe: (symbol: string) => void\n  unsubscribe: (symbol: string) => void\n  getSymbolData: (symbol: string) => MarketDataUpdate | null\n  getOrderBook: (symbol: string) => OrderBookUpdate | null\n  getCandlesticks: (symbol: string) => CandlestickData[]\n  getIndicators: (symbol: string) => TechnicalIndicator[]\n  clearError: () => void\n}\n\nexport const useRealTimeMarketData = ({\n  symbols = [],\n  enableOrderBook = false,\n  enableCandlesticks = false,\n  enableIndicators = false,\n  candlestickTimeframe = '1m',\n  indicators = ['RSI', 'SMA20', 'MACD'],\n  autoConnect = true\n}: UseRealTimeMarketDataOptions): UseRealTimeMarketDataReturn => {\n  const [state, setState] = useState<MarketDataState>({\n    marketData: {},\n    orderBooks: {},\n    candlesticks: {},\n    indicators: {},\n    isConnected: false,\n    connectionStatus: 'disconnected',\n    subscriptions: 0,\n    lastUpdate: null,\n    error: null\n  })\n\n  const subscriptionsRef = useRef<Map<string, string[]>>(new Map())\n  const isInitializedRef = useRef(false)\n\n  // Update connection status\n  const updateConnectionStatus = useCallback(() => {\n    const status = enhancedWebSocketService.getConnectionStatus()\n    setState(prev => ({\n      ...prev,\n      isConnected: status.isConnected,\n      connectionStatus: status.status,\n      subscriptions: status.subscriptions\n    }))\n  }, [])\n\n  // Handle market data updates\n  const handleMarketDataUpdate = useCallback((symbol: string, data: MarketDataUpdate) => {\n    setState(prev => ({\n      ...prev,\n      marketData: {\n        ...prev.marketData,\n        [symbol]: data\n      },\n      lastUpdate: new Date(),\n      error: null\n    }))\n  }, [])\n\n  // Handle order book updates\n  const handleOrderBookUpdate = useCallback((symbol: string, data: OrderBookUpdate) => {\n    setState(prev => ({\n      ...prev,\n      orderBooks: {\n        ...prev.orderBooks,\n        [symbol]: data\n      },\n      lastUpdate: new Date()\n    }))\n  }, [])\n\n  // Handle candlestick updates\n  const handleCandlestickUpdate = useCallback((symbol: string, data: CandlestickData) => {\n    setState(prev => {\n      const existing = prev.candlesticks[symbol] || []\n      const updated = [...existing, data]\n      \n      // Keep only last 500 candlesticks per symbol\n      if (updated.length > 500) {\n        updated.shift()\n      }\n      \n      return {\n        ...prev,\n        candlesticks: {\n          ...prev.candlesticks,\n          [symbol]: updated\n        },\n        lastUpdate: new Date()\n      }\n    })\n  }, [])\n\n  // Handle technical indicator updates\n  const handleIndicatorUpdate = useCallback((symbol: string, data: TechnicalIndicator[]) => {\n    setState(prev => ({\n      ...prev,\n      indicators: {\n        ...prev.indicators,\n        [symbol]: data\n      },\n      lastUpdate: new Date()\n    }))\n  }, [])\n\n  // Connect to WebSocket service\n  const connect = useCallback(async () => {\n    try {\n      setState(prev => ({ ...prev, error: null }))\n      await enhancedWebSocketService.connect()\n      updateConnectionStatus()\n    } catch (error) {\n      console.error('Failed to connect to market data service:', error)\n      setState(prev => ({\n        ...prev,\n        error: error instanceof Error ? error.message : 'Connection failed',\n        connectionStatus: 'error'\n      }))\n    }\n  }, [updateConnectionStatus])\n\n  // Disconnect from WebSocket service\n  const disconnect = useCallback(() => {\n    // Unsubscribe from all active subscriptions\n    for (const [symbol, subscriptionIds] of subscriptionsRef.current) {\n      subscriptionIds.forEach(id => {\n        enhancedWebSocketService.unsubscribe(id)\n      })\n    }\n    subscriptionsRef.current.clear()\n    \n    enhancedWebSocketService.disconnect()\n    updateConnectionStatus()\n  }, [updateConnectionStatus])\n\n  // Subscribe to a symbol\n  const subscribe = useCallback((symbol: string) => {\n    if (!state.isConnected) {\n      console.warn('Cannot subscribe: WebSocket not connected')\n      return\n    }\n\n    const existingSubscriptions = subscriptionsRef.current.get(symbol) || []\n    const newSubscriptions: string[] = []\n\n    // Subscribe to market data\n    const marketDataId = enhancedWebSocketService.subscribeMarketData(symbol, (data) => {\n      handleMarketDataUpdate(symbol, data)\n    })\n    newSubscriptions.push(marketDataId)\n\n    // Subscribe to order book if enabled\n    if (enableOrderBook) {\n      const orderBookId = enhancedWebSocketService.subscribeOrderBook(symbol, (data) => {\n        handleOrderBookUpdate(symbol, data)\n      })\n      newSubscriptions.push(orderBookId)\n    }\n\n    // Subscribe to candlesticks if enabled\n    if (enableCandlesticks) {\n      const candlestickId = enhancedWebSocketService.subscribeCandlestick(symbol, candlestickTimeframe, (data) => {\n        handleCandlestickUpdate(symbol, data)\n      })\n      newSubscriptions.push(candlestickId)\n    }\n\n    // Subscribe to indicators if enabled\n    if (enableIndicators) {\n      const indicatorId = enhancedWebSocketService.subscribeIndicators(symbol, indicators, (data) => {\n        handleIndicatorUpdate(symbol, data)\n      })\n      newSubscriptions.push(indicatorId)\n    }\n\n    subscriptionsRef.current.set(symbol, [...existingSubscriptions, ...newSubscriptions])\n    updateConnectionStatus()\n  }, [\n    state.isConnected,\n    enableOrderBook,\n    enableCandlesticks,\n    enableIndicators,\n    candlestickTimeframe,\n    indicators,\n    handleMarketDataUpdate,\n    handleOrderBookUpdate,\n    handleCandlestickUpdate,\n    handleIndicatorUpdate,\n    updateConnectionStatus\n  ])\n\n  // Unsubscribe from a symbol\n  const unsubscribe = useCallback((symbol: string) => {\n    const subscriptionIds = subscriptionsRef.current.get(symbol)\n    if (subscriptionIds) {\n      subscriptionIds.forEach(id => {\n        enhancedWebSocketService.unsubscribe(id)\n      })\n      subscriptionsRef.current.delete(symbol)\n      \n      // Remove data for unsubscribed symbol\n      setState(prev => {\n        const { [symbol]: removedMarket, ...restMarket } = prev.marketData\n        const { [symbol]: removedBook, ...restBooks } = prev.orderBooks\n        const { [symbol]: removedCandles, ...restCandles } = prev.candlesticks\n        const { [symbol]: removedIndicators, ...restIndicators } = prev.indicators\n        \n        return {\n          ...prev,\n          marketData: restMarket,\n          orderBooks: restBooks,\n          candlesticks: restCandles,\n          indicators: restIndicators\n        }\n      })\n      \n      updateConnectionStatus()\n    }\n  }, [updateConnectionStatus])\n\n  // Get symbol data\n  const getSymbolData = useCallback((symbol: string): MarketDataUpdate | null => {\n    return state.marketData[symbol] || null\n  }, [state.marketData])\n\n  // Get order book\n  const getOrderBook = useCallback((symbol: string): OrderBookUpdate | null => {\n    return state.orderBooks[symbol] || null\n  }, [state.orderBooks])\n\n  // Get candlesticks\n  const getCandlesticks = useCallback((symbol: string): CandlestickData[] => {\n    return state.candlesticks[symbol] || []\n  }, [state.candlesticks])\n\n  // Get indicators\n  const getIndicators = useCallback((symbol: string): TechnicalIndicator[] => {\n    return state.indicators[symbol] || []\n  }, [state.indicators])\n\n  // Clear error\n  const clearError = useCallback(() => {\n    setState(prev => ({ ...prev, error: null }))\n  }, [])\n\n  // Set up event listeners\n  useEffect(() => {\n    const handleConnected = () => updateConnectionStatus()\n    const handleDisconnected = () => updateConnectionStatus()\n    const handleStatus = () => updateConnectionStatus()\n    const handleError = (error: Error) => {\n      setState(prev => ({\n        ...prev,\n        error: error.message,\n        connectionStatus: 'error'\n      }))\n    }\n\n    enhancedWebSocketService.on('connected', handleConnected)\n    enhancedWebSocketService.on('disconnected', handleDisconnected)\n    enhancedWebSocketService.on('status', handleStatus)\n    enhancedWebSocketService.on('error', handleError)\n\n    return () => {\n      enhancedWebSocketService.off('connected', handleConnected)\n      enhancedWebSocketService.off('disconnected', handleDisconnected)\n      enhancedWebSocketService.off('status', handleStatus)\n      enhancedWebSocketService.off('error', handleError)\n    }\n  }, [updateConnectionStatus])\n\n  // Auto-connect and subscribe to initial symbols\n  useEffect(() => {\n    if (isInitializedRef.current) return\n    isInitializedRef.current = true\n\n    const initialize = async () => {\n      if (autoConnect) {\n        await connect()\n        \n        // Subscribe to initial symbols after connection\n        setTimeout(() => {\n          symbols.forEach(symbol => {\n            subscribe(symbol)\n          })\n        }, 100)\n      }\n    }\n\n    initialize()\n  }, [symbols, autoConnect, connect, subscribe])\n\n  // Subscribe to new symbols when symbols array changes\n  useEffect(() => {\n    if (!isInitializedRef.current || !state.isConnected) return\n    \n    const currentSymbols = new Set(Array.from(subscriptionsRef.current.keys()))\n    const newSymbols = symbols.filter(symbol => !currentSymbols.has(symbol))\n    const removedSymbols = Array.from(currentSymbols).filter(symbol => !symbols.includes(symbol))\n    \n    // Subscribe to new symbols\n    newSymbols.forEach(symbol => {\n      subscribe(symbol)\n    })\n    \n    // Unsubscribe from removed symbols\n    removedSymbols.forEach(symbol => {\n      unsubscribe(symbol)\n    })\n  }, [symbols, state.isConnected, subscribe, unsubscribe])\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      disconnect()\n    }\n  }, [disconnect])\n\n  return {\n    ...state,\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n    getSymbolData,\n    getOrderBook,\n    getCandlesticks,\n    getIndicators,\n    clearError\n  }\n}\n\nexport default useRealTimeMarketData