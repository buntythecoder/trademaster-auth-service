package com.trademaster.trading.dto;

import com.trademaster.trading.entity.Position;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.math.BigDecimal;\nimport java.time.Instant;\nimport java.time.LocalDate;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Portfolio Snapshot DTO\n * \n * Comprehensive real-time portfolio state with:\n * - Current positions and valuations\n * - P&L analysis with attribution\n * - Risk metrics and exposure analysis\n * - Performance benchmarking\n * - Cash and margin details\n * - Sector and industry breakdown\n * - Real-time market data integration\n * \n * @author TradeMaster Development Team\n * @version 1.0.0\n */\n@Data\n@Builder\n@NoArgsConstructor\n@AllArgsConstructor\npublic class PortfolioSnapshot {\n    \n    /**\n     * Basic Portfolio Information\n     */\n    private Long userId;\n    private Instant snapshotTime;\n    private LocalDate snapshotDate;\n    private String portfolioId;\n    private String portfolioName;\n    \n    /**\n     * Portfolio Valuation\n     */\n    private BigDecimal totalValue; // Total portfolio market value\n    private BigDecimal cashBalance; // Available cash\n    private BigDecimal investedValue; // Value of invested positions\n    private BigDecimal marginUsed; // Margin currently used\n    private BigDecimal buyingPower; // Available buying power\n    private BigDecimal totalEquity; // Total account equity\n    private BigDecimal netLiquidationValue; // Net liquidation value\n    \n    /**\n     * P&L Analysis\n     */\n    private BigDecimal totalPnL; // Total realized + unrealized P&L\n    private BigDecimal realizedPnL; // Realized P&L from closed positions\n    private BigDecimal unrealizedPnL; // Unrealized P&L from open positions\n    private BigDecimal intradayPnL; // Intraday P&L change\n    private BigDecimal previousDayValue; // Previous trading day close value\n    private BigDecimal dayChange; // Change since previous close\n    private BigDecimal dayChangePercent; // Day change percentage\n    \n    /**\n     * Performance Metrics\n     */\n    private BigDecimal totalReturnPercent; // Total return percentage\n    private BigDecimal annualizedReturn; // Annualized return\n    private BigDecimal monthToDateReturn; // MTD return\n    private BigDecimal yearToDateReturn; // YTD return\n    private BigDecimal oneYearReturn; // 1-year return\n    private BigDecimal threeYearReturn; // 3-year return\n    private BigDecimal inceptionReturn; // Return since account inception\n    \n    /**\n     * Risk Metrics\n     */\n    private BigDecimal portfolioVaR; // Value at Risk (95% confidence)\n    private BigDecimal expectedShortfall; // Expected shortfall (CVaR)\n    private BigDecimal portfolioBeta; // Beta to market benchmark\n    private BigDecimal portfolioVolatility; // Portfolio volatility\n    private BigDecimal sharpeRatio; // Risk-adjusted return\n    private BigDecimal sortinoRatio; // Downside risk-adjusted return\n    private BigDecimal maxDrawdown; // Maximum drawdown\n    private BigDecimal currentDrawdown; // Current drawdown from peak\n    \n    /**\n     * Position Details\n     */\n    private Integer totalPositions; // Number of positions\n    private Integer longPositions; // Number of long positions\n    private Integer shortPositions; // Number of short positions\n    private List<Position> positions; // All current positions\n    private List<Position> topGainers; // Top gaining positions\n    private List<Position> topLosers; // Top losing positions\n    private List<Position> largestPositions; // Largest positions by value\n    \n    /**\n     * Sector and Industry Breakdown\n     */\n    private Map<String, SectorAllocation> sectorBreakdown;\n    private Map<String, IndustryAllocation> industryBreakdown;\n    private Map<String, AssetClassAllocation> assetClassBreakdown;\n    \n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class SectorAllocation {\n        private String sectorName;\n        private BigDecimal marketValue;\n        private BigDecimal percentage;\n        private BigDecimal dayChange;\n        private BigDecimal dayChangePercent;\n        private Integer positionCount;\n        private BigDecimal sectorBeta;\n        private List<String> topSymbols;\n    }\n    \n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class IndustryAllocation {\n        private String industryName;\n        private BigDecimal marketValue;\n        private BigDecimal percentage;\n        private BigDecimal dayChange;\n        private Integer positionCount;\n        private List<String> symbols;\n    }\n    \n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class AssetClassAllocation {\n        private String assetClass;\n        private BigDecimal marketValue;\n        private BigDecimal percentage;\n        private BigDecimal expectedReturn;\n        private BigDecimal volatility;\n        private Integer positionCount;\n    }\n    \n    /**\n     * Concentration Analysis\n     */\n    private BigDecimal concentrationRisk; // Portfolio concentration score\n    private BigDecimal topTenConcentration; // Top 10 positions concentration\n    private BigDecimal sectorConcentration; // Largest sector concentration\n    private BigDecimal singleStockLimit; // Max single stock percentage\n    private List<ConcentrationAlert> concentrationAlerts;\n    \n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class ConcentrationAlert {\n        private String alertType; // SINGLE_STOCK, SECTOR, INDUSTRY\n        private String name; // Stock/sector/industry name\n        private BigDecimal currentPercentage;\n        private BigDecimal threshold;\n        private String severity; // LOW, MEDIUM, HIGH, CRITICAL\n        private String recommendation;\n    }\n    \n    /**\n     * Trading Activity\n     */\n    private Integer tradesThisMonth; // Number of trades this month\n    private Integer tradesThisYear; // Number of trades this year\n    private BigDecimal averageTradeSize; // Average trade size\n    private BigDecimal tradingVolume; // Total trading volume\n    private BigDecimal turnoverRate; // Portfolio turnover rate\n    private BigDecimal tradingCosts; // Total trading costs\n    private BigDecimal costDragPercent; // Cost drag on performance\n    \n    /**\n     * Margin and Leverage\n     */\n    private BigDecimal leverageRatio; // Portfolio leverage ratio\n    private BigDecimal marginRequirement; // Total margin requirement\n    private BigDecimal marginUtilization; // Margin utilization percentage\n    private BigDecimal interestCharges; // Interest charges on margin\n    private BigDecimal borrowingCosts; // Cost of borrowed securities\n    private BigDecimal maintenanceMargin; // Maintenance margin requirement\n    \n    /**\n     * Performance Attribution\n     */\n    private Map<String, BigDecimal> sectorAttribution; // P&L attribution by sector\n    private Map<String, BigDecimal> stockAttribution; // P&L attribution by stock\n    private Map<String, BigDecimal> assetAllocationEffect; // Asset allocation effect\n    private Map<String, BigDecimal> stockSelectionEffect; // Stock selection effect\n    private Map<String, BigDecimal> interactionEffect; // Interaction effect\n    \n    /**\n     * Benchmark Comparison\n     */\n    private String primaryBenchmark; // Primary benchmark (e.g., NIFTY50)\n    private BigDecimal benchmarkValue; // Benchmark current value\n    private BigDecimal benchmarkDayChange; // Benchmark day change\n    private BigDecimal benchmarkYTDReturn; // Benchmark YTD return\n    private BigDecimal activeReturn; // Portfolio return - benchmark return\n    private BigDecimal trackingError; // Tracking error vs benchmark\n    private BigDecimal informationRatio; // Information ratio\n    private BigDecimal upCaptureRatio; // Up capture ratio\n    private BigDecimal downCaptureRatio; // Down capture ratio\n    \n    /**\n     * Portfolio Health Indicators\n     */\n    private BigDecimal healthScore; // Overall portfolio health (0-100)\n    private List<String> healthFactors; // Factors affecting health\n    private List<String> recommendations; // Portfolio recommendations\n    private List<PortfolioAlert> activeAlerts; // Active portfolio alerts\n    \n    @Data\n    @Builder\n    @NoArgsConstructor\n    @AllArgsConstructor\n    public static class PortfolioAlert {\n        private String alertId;\n        private String alertType; // RISK, CONCENTRATION, PERFORMANCE, MARGIN\n        private String severity; // INFO, WARNING, CRITICAL\n        private String message;\n        private BigDecimal threshold;\n        private BigDecimal currentValue;\n        private Instant triggeredAt;\n        private String recommendedAction;\n        private Boolean acknowledged;\n    }\n    \n    /**\n     * Market Data Context\n     */\n    private String marketStatus; // OPEN, CLOSED, PRE_MARKET, AFTER_HOURS\n    private Instant lastMarketDataUpdate; // Last market data timestamp\n    private Integer stalePriceCount; // Number of positions with stale prices\n    private BigDecimal marketDataLatency; // Average market data latency\n    private List<String> dataQualityIssues; // Data quality issues\n    \n    /**\n     * Calculated Properties and Helper Methods\n     */\n    \n    /**\n     * Calculate portfolio allocation percentage for a position\n     */\n    public BigDecimal getPositionWeight(Position position) {\n        if (totalValue == null || totalValue.compareTo(BigDecimal.ZERO) == 0 ||\n            position.getMarketValue() == null) {\n            return BigDecimal.ZERO;\n        }\n        return position.getMarketValue().divide(totalValue, 4, java.math.RoundingMode.HALF_UP)\n               .multiply(BigDecimal.valueOf(100));\n    }\n    \n    /**\n     * Get cash allocation percentage\n     */\n    public BigDecimal getCashAllocationPercent() {\n        if (totalValue == null || totalValue.compareTo(BigDecimal.ZERO) == 0 ||\n            cashBalance == null) {\n            return BigDecimal.ZERO;\n        }\n        return cashBalance.divide(totalValue, 4, java.math.RoundingMode.HALF_UP)\n               .multiply(BigDecimal.valueOf(100));\n    }\n    \n    /**\n     * Get invested allocation percentage\n     */\n    public BigDecimal getInvestedAllocationPercent() {\n        if (totalValue == null || totalValue.compareTo(BigDecimal.ZERO) == 0 ||\n            investedValue == null) {\n            return BigDecimal.ZERO;\n        }\n        return investedValue.divide(totalValue, 4, java.math.RoundingMode.HALF_UP)\n               .multiply(BigDecimal.valueOf(100));\n    }\n    \n    /**\n     * Check if portfolio is diversified\n     */\n    public boolean isDiversified() {\n        return concentrationRisk != null && \n               concentrationRisk.compareTo(new BigDecimal(\"0.3\")) <= 0 &&\n               (sectorBreakdown != null && sectorBreakdown.size() >= 5);\n    }\n    \n    /**\n     * Check if portfolio is over-leveraged\n     */\n    public boolean isOverLeveraged() {\n        return leverageRatio != null && \n               leverageRatio.compareTo(new BigDecimal(\"2.0\")) > 0;\n    }\n    \n    /**\n     * Check if margin utilization is high\n     */\n    public boolean isHighMarginUtilization() {\n        return marginUtilization != null && \n               marginUtilization.compareTo(new BigDecimal(\"75.0\")) > 0;\n    }\n    \n    /**\n     * Get performance category based on returns\n     */\n    public String getPerformanceCategory() {\n        if (totalReturnPercent == null) {\n            return \"UNKNOWN\";\n        }\n        \n        BigDecimal returnPct = totalReturnPercent;\n        if (returnPct.compareTo(new BigDecimal(\"20\")) > 0) {\n            return \"EXCELLENT\";\n        } else if (returnPct.compareTo(new BigDecimal(\"10\")) > 0) {\n            return \"GOOD\";\n        } else if (returnPct.compareTo(new BigDecimal(\"0\")) >= 0) {\n            return \"POSITIVE\";\n        } else if (returnPct.compareTo(new BigDecimal(\"-10\")) > 0) {\n            return \"NEGATIVE\";\n        } else {\n            return \"POOR\";\n        }\n    }\n    \n    /**\n     * Get risk category based on risk metrics\n     */\n    public String getRiskCategory() {\n        if (portfolioVaR == null) {\n            return \"UNKNOWN\";\n        }\n        \n        // VaR as percentage of portfolio value\n        BigDecimal varPercent = portfolioVaR.divide(totalValue, 4, java.math.RoundingMode.HALF_UP)\n                                            .multiply(BigDecimal.valueOf(100));\n        \n        if (varPercent.compareTo(new BigDecimal(\"2\")) <= 0) {\n            return \"LOW\";\n        } else if (varPercent.compareTo(new BigDecimal(\"5\")) <= 0) {\n            return \"MODERATE\";\n        } else if (varPercent.compareTo(new BigDecimal(\"10\")) <= 0) {\n            return \"HIGH\";\n        } else {\n            return \"VERY_HIGH\";\n        }\n    }\n    \n    /**\n     * Check if portfolio needs rebalancing\n     */\n    public boolean needsRebalancing() {\n        // Simple rebalancing check based on concentration\n        return concentrationRisk != null && \n               concentrationRisk.compareTo(new BigDecimal(\"0.4\")) > 0;\n    }\n    \n    /**\n     * Get portfolio summary statistics\n     */\n    public Map<String, Object> getSummaryStats() {\n        return Map.of(\n            \"totalValue\", totalValue != null ? totalValue : BigDecimal.ZERO,\n            \"totalPnL\", totalPnL != null ? totalPnL : BigDecimal.ZERO,\n            \"dayChange\", dayChange != null ? dayChange : BigDecimal.ZERO,\n            \"dayChangePercent\", dayChangePercent != null ? dayChangePercent : BigDecimal.ZERO,\n            \"totalPositions\", totalPositions != null ? totalPositions : 0,\n            \"performanceCategory\", getPerformanceCategory(),\n            \"riskCategory\", getRiskCategory(),\n            \"healthScore\", healthScore != null ? healthScore : BigDecimal.ZERO,\n            \"needsRebalancing\", needsRebalancing()\n        );\n    }\n    \n    /**\n     * Static factory methods\n     */\n    public static PortfolioSnapshot empty(Long userId) {\n        return PortfolioSnapshot.builder()\n            .userId(userId)\n            .snapshotTime(Instant.now())\n            .snapshotDate(LocalDate.now())\n            .totalValue(BigDecimal.ZERO)\n            .cashBalance(BigDecimal.ZERO)\n            .totalPositions(0)\n            .healthScore(new BigDecimal(\"50\"))\n            .build();\n    }\n    \n    /**\n     * Create snapshot with error state\n     */\n    public static PortfolioSnapshot error(Long userId, String errorMessage) {\n        return PortfolioSnapshot.builder()\n            .userId(userId)\n            .snapshotTime(Instant.now())\n            .snapshotDate(LocalDate.now())\n            .totalValue(BigDecimal.ZERO)\n            .healthScore(BigDecimal.ZERO)\n            .dataQualityIssues(List.of(errorMessage))\n            .build();\n    }\n}"