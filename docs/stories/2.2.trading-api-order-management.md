# Story 2.2: Trading API & Order Management

## Status
Draft

## Story
**As a** TradeMaster user with authenticated account,
**I want** to place, manage, and track trading orders with comprehensive risk checks and real-time execution status,
**so that** I can execute my trading strategies safely while maintaining complete visibility into my order lifecycle.

## Acceptance Criteria

1. Users can place buy/sell orders through REST API endpoints
2. Order validation includes balance checks, position limits, and risk parameters
3. Trade execution integrates with broker APIs for actual market orders  
4. Portfolio positions are updated in real-time after trade execution
5. P&L calculations are accurate and update automatically with market prices
6. Order history and trade records are maintained with complete audit trail
7. System supports market orders, limit orders, and stop-loss orders
8. Pre-trade risk checks prevent violations of user-defined risk limits
9. Order status tracking provides real-time updates on execution progress
10. Trade settlement and clearing processes are automated where possible

## Tasks / Subtasks

- [ ] **Task 1: Trading API Core Infrastructure** (AC: 1, 7, 8)
  - [ ] Create Trading API service with Spring Boot WebFlux for reactive programming
  - [ ] Implement REST endpoints for order placement, modification, and cancellation
  - [ ] Set up order validation framework with configurable business rules
  - [ ] Create order routing logic for different order types (market, limit, stop-loss)
  - [ ] Implement pre-trade risk check engine with position and balance validation
  - [ ] Add order authentication and authorization using JWT from Epic 1
  - [ ] Create order ID generation and lifecycle state management

- [ ] **Task 2: Broker Integration & Order Execution** (AC: 3, 9, 10)
  - [ ] Research and integrate with Indian broker APIs (Zerodha Kite, Upstox, etc.)
  - [ ] Implement order routing to appropriate broker based on user account
  - [ ] Create order execution monitoring with real-time status updates
  - [ ] Add order acknowledgment and fill notification handling
  - [ ] Implement order rejection and error handling from broker APIs
  - [ ] Set up trade settlement processing and clearing integration
  - [ ] Create broker API failover and redundancy mechanisms

- [ ] **Task 3: Order Management System** (AC: 6, 9)
  - [ ] Design and implement order lifecycle state machine
  - [ ] Create order modification and cancellation capabilities
  - [ ] Implement order history tracking with complete audit trail
  - [ ] Add order status broadcasting via WebSocket for real-time updates
  - [ ] Create order search and filtering capabilities
  - [ ] Implement partial fill handling and order quantity tracking
  - [ ] Add order expiration and time-in-force management

- [ ] **Task 4: Portfolio Management Integration** (AC: 4, 5)
  - [ ] Implement real-time portfolio position updates after trade execution
  - [ ] Create position aggregation logic for multiple trades in same symbol
  - [ ] Add average price calculation for position cost basis
  - [ ] Implement unrealized P&L calculation using live market prices
  - [ ] Create realized P&L tracking for closed positions
  - [ ] Add portfolio value calculation and performance metrics
  - [ ] Implement position-level risk metrics and exposure calculations

- [ ] **Task 5: Risk Management Engine** (AC: 2, 8)
  - [ ] Create configurable risk parameters per user and subscription tier
  - [ ] Implement position size limits and concentration risk checks
  - [ ] Add buying power and margin requirement calculations
  - [ ] Create maximum loss limits and stop-loss automation
  - [ ] Implement day trading buying power and pattern day trader rules
  - [ ] Add sector and stock-specific exposure limits
  - [ ] Create risk override capabilities for institutional users

- [ ] **Task 6: Database Schema & Data Management** (AC: 4, 5, 6)
  - [ ] Extend PostgreSQL schema with orders, trades, and positions tables
  - [ ] Implement database indexes for optimal query performance
  - [ ] Create data archiving strategy for historical orders and trades
  - [ ] Add database constraints to ensure data integrity
  - [ ] Implement audit logging for all trading-related database changes
  - [ ] Create backup and recovery procedures for trading data
  - [ ] Set up database replication for high availability

- [ ] **Task 7: Performance Optimization & Caching** (AC: All)
  - [ ] Implement Redis caching for frequently accessed portfolio data
  - [ ] Add database connection pooling optimized for trading workloads
  - [ ] Create async processing for non-critical trading operations
  - [ ] Implement order book caching and real-time updates
  - [ ] Add performance monitoring and latency tracking
  - [ ] Optimize database queries for trading performance requirements
  - [ ] Implement circuit breaker patterns for external broker API calls

- [ ] **Task 8: Unit and Integration Testing** (AC: All)
  - [ ] Write unit tests for order validation and risk check logic
  - [ ] Create integration tests for broker API connectivity and responses
  - [ ] Test portfolio position updates and P&L calculations
  - [ ] Test order lifecycle state transitions and error handling
  - [ ] Test concurrent order processing and race condition handling
  - [ ] Create load testing for high-volume trading scenarios
  - [ ] Test database transaction integrity for trading operations
  - [ ] Test WebSocket order status updates and client synchronization

## Dev Notes

### Previous Story Insights
**From Story 1.1:** Authentication system provides JWT tokens and user session management for secure trading API access.
**From Story 2.1:** Market data service provides real-time price feeds needed for P&L calculations and risk management.

### Data Models
**Source: [docs/architecture/data-architecture.md#postgresql-primary-transactional-database]**

**Trading Schema Extensions:**
```sql
CREATE TABLE trades (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    symbol VARCHAR(20) NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    trade_type VARCHAR(10) CHECK (trade_type IN ('BUY', 'SELL')),
    status VARCHAR(20) DEFAULT 'pending',
    executed_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE portfolios (
    user_id INTEGER REFERENCES users(id),
    symbol VARCHAR(20) NOT NULL,
    quantity INTEGER NOT NULL,
    avg_price DECIMAL(10,2) NOT NULL,
    unrealized_pnl DECIMAL(15,2),
    updated_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (user_id, symbol)
);
```

**Additional Trading Tables (to be created):**
```sql
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    symbol VARCHAR(20) NOT NULL,
    order_type VARCHAR(20) NOT NULL, -- MARKET, LIMIT, STOP_LOSS
    side VARCHAR(10) NOT NULL, -- BUY, SELL
    quantity INTEGER NOT NULL,
    price DECIMAL(10,2),
    stop_price DECIMAL(10,2),
    status VARCHAR(20) DEFAULT 'pending',
    broker_order_id VARCHAR(100),
    filled_quantity INTEGER DEFAULT 0,
    avg_fill_price DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE order_fills (
    id SERIAL PRIMARY KEY, 
    order_id INTEGER REFERENCES orders(id),
    fill_quantity INTEGER NOT NULL,
    fill_price DECIMAL(10,2) NOT NULL,
    fill_time TIMESTAMP NOT NULL,
    broker_fill_id VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);
```

### API Specifications
**Source: [docs/architecture/core-services-architecture.md#3-trading-api-service]**

**Technology Stack:**
- Spring Boot 3.x with WebFlux (reactive programming)
- PostgreSQL for transactional data
- Redis for caching

**Trading API Endpoints:**
- `/api/v1/trades` - Execute trades with validation
- `/api/v1/portfolio` - Portfolio management and P&L
- `/api/v1/positions` - Real-time position tracking
- `/api/v1/orders` - Order management and history

**Performance Requirements:**
- Order execution: <50ms latency
- Portfolio updates: Real-time via WebSocket
- Concurrent users: 10,000+ simultaneous

**Extended Trading Endpoints (to be implemented):**
- `POST /api/v1/orders` - Place new order
- `GET /api/v1/orders` - Get order history
- `GET /api/v1/orders/{orderId}` - Get order details
- `PUT /api/v1/orders/{orderId}` - Modify existing order
- `DELETE /api/v1/orders/{orderId}` - Cancel order
- `GET /api/v1/portfolio/positions` - Get current positions
- `GET /api/v1/portfolio/performance` - Get portfolio performance metrics
- `WebSocket /ws/orders` - Real-time order status updates

### Risk Management Requirements
**Source: [docs/architecture/security-architecture.md#financial-security]**

**Trading Security:**
- Pre-trade risk checks and position limits
- Real-time fraud detection algorithms  
- Suspicious activity monitoring
- Automated account freezing for anomalies

**Risk Check Implementation:**
```java
@Service
public class RiskManagementService {
    
    public RiskCheckResult validateOrder(Order order, User user, Portfolio portfolio) {
        // Check buying power and margin requirements
        // Validate position size limits
        // Check concentration risk
        // Verify day trading rules compliance
        // Validate against user-defined risk parameters
        return riskCheckResult;
    }
}
```

### Broker Integration Architecture
**Integration Requirements:**
- Support for major Indian brokers (Zerodha Kite API, Upstox API, Angel One API)
- Order routing based on user broker account configuration
- Real-time order status synchronization
- Trade settlement and clearing integration
- Broker-specific order type mapping and validation

**Broker API Integration Pattern:**
```java
@Service
public interface BrokerService {
    OrderResponse placeOrder(BrokerOrder order);
    OrderStatus getOrderStatus(String brokerOrderId);
    void cancelOrder(String brokerOrderId);
    List<Position> getPositions(String userId);
    BalanceInfo getBalance(String userId);
}
```

### File Locations
**Project Structure:** Spring Boot microservices architecture:
- `src/main/java/com/trademaster/trading/` - Trading service classes
- `src/main/java/com/trademaster/trading/service/` - Trading business logic
- `src/main/java/com/trademaster/trading/controller/` - Trading API controllers
- `src/main/java/com/trademaster/trading/model/` - Order and portfolio models
- `src/main/java/com/trademaster/trading/risk/` - Risk management components
- `src/main/java/com/trademaster/trading/broker/` - Broker integration interfaces
- `src/main/java/com/trademaster/trading/websocket/` - Real-time order updates
- `src/main/resources/application.yml` - Trading service configuration

### Performance Requirements
**Source: [docs/architecture/performance-scalability.md#performance-targets]**

**Trading Performance Targets:**
- Order placement API: <50ms response time
- Order execution latency: <200ms end-to-end
- Portfolio update propagation: <10ms via WebSocket
- Risk check processing: <25ms per order
- Database transaction processing: <100ms for complex trades

**Scalability Requirements:**
- Support 10,000+ concurrent trading users
- Process 1,000+ orders per second during peak hours
- Handle 100,000+ portfolio position updates per day
- Maintain 99.9% uptime during market hours

### Technical Constraints
**Source: [docs/architecture/core-services-architecture.md#3-trading-api-service]**

**Technology Requirements:**
- Java 21 with Spring Boot 3.x WebFlux for reactive programming
- PostgreSQL with connection pooling for transactional integrity
- Redis for sub-30ms caching of portfolio data
- WebSocket for real-time order and position updates

**Integration Constraints:**
- Must use JWT authentication from Epic 1 authentication service
- Market data integration with Epic 2.1 for real-time pricing
- Compliance with Indian trading regulations and broker requirements
- Support for multiple broker APIs with unified interface

### Audit and Compliance
**Source: [docs/architecture/security-architecture.md#financial-security]**

**Audit Requirements:**
- Complete audit trail for all transactions
- Immutable logging with blockchain signatures
- Regulatory reporting automation
- SEBI compliance monitoring

**Compliance Implementation:**
```java
@Component
public class TradingAuditLogger {
    
    public void logOrderPlacement(Order order, User user) {
        // Log order details with immutable signature
        // Record user authentication context
        // Capture risk check results
        // Store regulatory compliance data
    }
    
    public void logTradeExecution(Trade trade, Order order) {
        // Log execution details and timestamps
        // Record broker confirmation details
        // Calculate and log fee structures
        // Update regulatory reporting data
    }
}
```

## Testing

### Testing Standards
**Testing Requirements:** The Developer should implement comprehensive testing following these guidelines:

**Test File Locations:**
- Unit tests: `src/test/java/com/trademaster/trading/`
- Integration tests: `src/test/java/com/trademaster/integration/trading/`
- Performance tests: `src/test/java/com/trademaster/performance/trading/`

**Testing Frameworks and Patterns:**
- JUnit 5 for unit testing framework
- Mockito for mocking broker APIs and external dependencies
- Spring Boot Test for integration testing
- TestContainers for PostgreSQL and Redis integration testing
- WebTestClient for REST API and WebSocket testing
- WireMock for broker API simulation and testing

**Specific Testing Requirements for This Story:**
- Test order validation logic for all order types and edge cases
- Verify risk management engine correctly prevents violations
- Test broker API integration with mock responses and error scenarios
- Validate portfolio position updates and P&L calculation accuracy
- Test order lifecycle state transitions and concurrent modification handling
- Verify WebSocket order status updates reach all subscribed clients
- Test database transaction integrity under high concurrency
- Load testing for 1,000+ orders per second processing
- Test order settlement and clearing process automation
- Validate audit logging captures all required trading events

**Trading-Specific Test Scenarios:**
- Test insufficient balance and buying power validation
- Verify position limit enforcement and concentration risk checks
- Test partial fill handling and average price calculations
- Validate stop-loss trigger and execution logic
- Test order expiration and time-in-force handling
- Verify portfolio performance metric calculations

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-05 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References  
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by QA Agent after story implementation review*