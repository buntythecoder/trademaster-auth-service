# Story 5.2: Subscription Tier Management & Feature Access Control

## Status
Draft

## Story
**As a** TradeMaster platform administrator and user,
**I want** a comprehensive subscription management system that controls feature access, handles billing, and manages tier transitions seamlessly,
**so that** users can access appropriate features based on their subscription level while the platform generates sustainable revenue.

## Acceptance Criteria

1. Subscription service manages four tiers: Free, Smart Trader, Professional, Institutional
2. Feature access control restricts functionality based on subscription tier
3. Billing integration handles payments, renewals, and failed payment recovery
4. Subscription upgrades and downgrades are processed seamlessly in real-time
5. Usage tracking monitors API calls, data access, and feature utilization per tier
6. Subscription analytics provide insights on user engagement and churn risk
7. Promotional campaigns and discount management support marketing initiatives
8. Subscription notifications keep users informed of billing events and renewals
9. Admin dashboard provides comprehensive subscription management and analytics
10. Subscription data integrates with all platform services for consistent access control

## Tasks / Subtasks

- [ ] **Task 1: Subscription Service Architecture** (AC: 1, 10)
  - [ ] Design subscription management service with tier-based access control
  - [ ] Implement subscription data models and persistence layer
  - [ ] Set up subscription event-driven architecture with other services
  - [ ] Create subscription API with RESTful endpoints
  - [ ] Implement subscription caching for high-performance access control
  - [ ] Set up subscription audit logging and compliance tracking
  - [ ] Create subscription service monitoring and health checks

- [ ] **Task 2: Tier-Based Feature Access Control** (AC: 2, 10)
  - [ ] Implement feature flag system integrated with subscription tiers
  - [ ] Create access control middleware for API endpoints and features
  - [ ] Set up real-time feature access validation across all services
  - [ ] Implement graceful degradation for tier downgrades
  - [ ] Create feature usage enforcement with rate limiting integration
  - [ ] Add feature access logging and audit trails
  - [ ] Set up feature access testing and validation framework

- [ ] **Task 3: Billing Integration & Payment Processing** (AC: 3, 8)
  - [ ] Integrate with payment processors (Stripe, Razorpay for Indian market)
  - [ ] Implement subscription billing cycles and automated renewals
  - [ ] Set up failed payment handling and dunning management
  - [ ] Create invoice generation and delivery system
  - [ ] Implement proration logic for mid-cycle tier changes
  - [ ] Add payment method management and customer billing portal
  - [ ] Set up billing notification system with email and push notifications

- [ ] **Task 4: Subscription Lifecycle Management** (AC: 4, 5)
  - [ ] Create subscription upgrade/downgrade workflow with immediate effect
  - [ ] Implement usage tracking and metering for API calls and data access
  - [ ] Set up subscription pause/resume functionality
  - [ ] Create subscription cancellation handling with retention campaigns
  - [ ] Implement trial period management and conversion tracking
  - [ ] Add subscription modification history and rollback capabilities
  - [ ] Set up subscription expiration handling and grace periods

- [ ] **Task 5: Analytics & Business Intelligence** (AC: 6, 9)
  - [ ] Create subscription analytics dashboard with key metrics
  - [ ] Implement churn prediction and risk scoring
  - [ ] Set up revenue analytics and forecasting
  - [ ] Create user engagement tracking correlated with subscription tiers
  - [ ] Implement cohort analysis for subscription retention
  - [ ] Add subscription conversion funnel analytics
  - [ ] Create automated reporting and business intelligence

- [ ] **Task 6: Promotional Campaigns & Discount Management** (AC: 7)
  - [ ] Design flexible discount and coupon system
  - [ ] Implement promotional campaign management with targeting
  - [ ] Create referral program with subscription benefits
  - [ ] Set up seasonal promotion and special offer management
  - [ ] Implement discount code validation and redemption tracking
  - [ ] Add promotional campaign analytics and ROI measurement
  - [ ] Create automated marketing campaign triggers

- [ ] **Task 7: Admin Dashboard & Management Interface** (AC: 9)
  - [ ] Create comprehensive subscription management admin interface
  - [ ] Implement customer support tools for subscription modifications
  - [ ] Set up subscription health monitoring and alerting
  - [ ] Create bulk subscription management operations
  - [ ] Add subscription dispute and refund management
  - [ ] Implement subscription compliance and regulatory reporting
  - [ ] Create subscription configuration management interface

- [ ] **Task 8: Unit and Integration Testing** (AC: All)
  - [ ] Test subscription tier access control across all services
  - [ ] Verify billing integration and payment processing accuracy
  - [ ] Test subscription lifecycle events and state transitions
  - [ ] Validate usage tracking and feature access enforcement
  - [ ] Test promotional campaign functionality and discount calculations
  - [ ] Load testing for subscription service under high traffic
  - [ ] Test subscription data consistency across distributed services
  - [ ] Validate subscription analytics accuracy and performance

## Dev Notes

### Previous Story Insights
**From Epic 1:** User authentication provides foundation for subscription user management and access control.
**From Story 1.3:** API Gateway rate limiting integrates with subscription tier limits and access control.
**From All Previous Epics:** Feature access control must integrate with trading, AI, mobile, and gamification services.

### Subscription Architecture
**Source: [docs/architecture/gamification-subscription-architecture.md#subscription-management]**

**Technology Stack:**
- Java 21, Spring Boot 3.x for subscription service
- PostgreSQL for subscription data persistence
- Redis for subscription caching and session management
- Apache Kafka for subscription event streaming

**Subscription Service Implementation:**
```java
@Service
public class SubscriptionService {
    
    @Autowired
    private SubscriptionRepository subscriptionRepository;
    
    @Autowired
    private BillingService billingService;
    
    @Autowired
    private FeatureAccessService featureAccessService;
    
    public SubscriptionTier getUserSubscriptionTier(Long userId) {
        return subscriptionRepository.findActiveByUserId(userId)
            .map(Subscription::getTier)
            .orElse(SubscriptionTier.FREE);
    }
    
    @Transactional
    public void upgradeSubscription(Long userId, SubscriptionTier newTier) {
        Subscription currentSubscription = getCurrentSubscription(userId);
        
        // Calculate prorated billing
        BigDecimal proratedAmount = billingService.calculateProration(
            currentSubscription, newTier);
        
        // Process payment
        PaymentResult payment = billingService.processPayment(userId, proratedAmount);
        
        if (payment.isSuccessful()) {
            // Update subscription
            currentSubscription.setTier(newTier);
            currentSubscription.setUpgradedAt(LocalDateTime.now());
            subscriptionRepository.save(currentSubscription);
            
            // Publish subscription change event
            publishSubscriptionChangeEvent(userId, newTier);
            
            // Update feature access immediately
            featureAccessService.updateUserAccess(userId, newTier);
        }
    }
}
```

### Subscription Data Models
**Subscription Entities:**
```java
@Entity
@Table(name = "subscriptions")
public class Subscription {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private Long userId;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private SubscriptionTier tier;
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private SubscriptionStatus status; // ACTIVE, PAST_DUE, CANCELLED, SUSPENDED
    
    @Column(nullable = false)
    private LocalDateTime startDate;
    
    @Column
    private LocalDateTime endDate;
    
    @Column
    private LocalDateTime nextBillingDate;
    
    @Column(nullable = false, precision = 10, scale = 2)
    private BigDecimal monthlyPrice;
    
    @Column
    private String stripeSubscriptionId;
    
    @Column
    private String razorpaySubscriptionId;
    
    @Enumerated(EnumType.STRING)
    private BillingCycle billingCycle = BillingCycle.MONTHLY;
    
    @Column
    private LocalDateTime trialEndDate;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

public enum SubscriptionTier {
    FREE(
        "Free",
        BigDecimal.ZERO,
        100,    // API calls per minute
        1000,   // API calls per day
        Set.of(Feature.BASIC_TRADING, Feature.PORTFOLIO_VIEW)
    ),
    SMART_TRADER(
        "Smart Trader",
        new BigDecimal("999.00"), // INR per month
        1000,   // API calls per minute
        10000,  // API calls per day
        Set.of(Feature.BASIC_TRADING, Feature.PORTFOLIO_VIEW, 
               Feature.ADVANCED_CHARTS, Feature.BASIC_AI)
    ),
    PROFESSIONAL(
        "Professional",
        new BigDecimal("2499.00"), // INR per month
        5000,   // API calls per minute
        100000, // API calls per day
        Set.of(Feature.BASIC_TRADING, Feature.PORTFOLIO_VIEW,
               Feature.ADVANCED_CHARTS, Feature.FULL_AI, 
               Feature.BEHAVIORAL_COACHING, Feature.INSTITUTIONAL_DATA)
    ),
    INSTITUTIONAL(
        "Institutional",
        new BigDecimal("9999.00"), // INR per month
        10000,  // API calls per minute
        1000000, // API calls per day
        Set.of() // All features enabled
    );
    
    private final String displayName;
    private final BigDecimal monthlyPrice;
    private final int apiCallsPerMinute;
    private final int apiCallsPerDay;
    private final Set<Feature> includedFeatures;
}
```

### Feature Access Control System
**Feature Flag Integration:**
```java
@Component
public class FeatureAccessService {
    
    @Cacheable(value = "userFeatures", key = "#userId")
    public Set<Feature> getUserFeatures(Long userId) {
        SubscriptionTier tier = subscriptionService.getUserSubscriptionTier(userId);
        return tier.getIncludedFeatures();
    }
    
    public boolean hasFeatureAccess(Long userId, Feature feature) {
        Set<Feature> userFeatures = getUserFeatures(userId);
        return userFeatures.contains(feature) || userFeatures.isEmpty(); // Institutional has all
    }
    
    @EventListener
    public void handleSubscriptionChange(SubscriptionChangeEvent event) {
        // Invalidate cache when subscription changes
        cacheManager.evict("userFeatures", event.getUserId());
        
        // Update real-time sessions
        websocketService.notifyFeatureAccessChange(event.getUserId());
    }
}

@RestController
@RequestMapping("/api/v1/premium")
public class PremiumFeatureController {
    
    @GetMapping("/behavioral-insights/{symbol}")
    @RequiresFeature(Feature.FULL_AI)
    public ResponseEntity<BehavioralInsights> getBehavioralInsights(
            @PathVariable String symbol,
            @AuthenticationPrincipal UserPrincipal user) {
        
        // Feature access is enforced by @RequiresFeature annotation
        BehavioralInsights insights = behavioralAIService.getInsights(user.getId(), symbol);
        return ResponseEntity.ok(insights);
    }
}
```

### Billing Integration
**Payment Processing with Multiple Providers:**
```java
@Service
public class BillingService {
    
    @Autowired
    private StripeService stripeService;
    
    @Autowired
    private RazorpayService razorpayService;
    
    public PaymentResult processSubscriptionPayment(Long userId, SubscriptionTier tier) {
        User user = userService.getUser(userId);
        
        // Determine payment provider based on user location
        PaymentProvider provider = determinePaymentProvider(user.getCountry());
        
        return switch (provider) {
            case STRIPE -> stripeService.createSubscription(user, tier);
            case RAZORPAY -> razorpayService.createSubscription(user, tier);
        };
    }
    
    @Scheduled(cron = "0 0 2 * * ?") // Daily at 2 AM
    public void processFailedPayments() {
        List<Subscription> pastDueSubscriptions = subscriptionRepository
            .findByStatusAndNextBillingDateBefore(
                SubscriptionStatus.PAST_DUE, 
                LocalDateTime.now().minusDays(1)
            );
        
        pastDueSubscriptions.forEach(this::attemptPaymentRecovery);
    }
    
    private void attemptPaymentRecovery(Subscription subscription) {
        PaymentResult result = retryPayment(subscription);
        
        if (result.isSuccessful()) {
            subscription.setStatus(SubscriptionStatus.ACTIVE);
            subscription.setNextBillingDate(calculateNextBillingDate(subscription));
        } else {
            // Send dunning email and potentially suspend account
            notificationService.sendPaymentFailureNotification(subscription.getUserId());
            
            if (subscription.getDaysPastDue() > 7) {
                suspendSubscription(subscription);
            }
        }
        
        subscriptionRepository.save(subscription);
    }
}
```

### Usage Tracking and Metering
**API Usage Monitoring:**
```java
@Component
public class UsageTrackingService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    public boolean checkAndRecordUsage(Long userId, UsageType usageType) {
        SubscriptionTier tier = subscriptionService.getUserSubscriptionTier(userId);
        
        String dailyKey = String.format("usage:%d:%s:%s", 
            userId, usageType, LocalDate.now());
        String minuteKey = String.format("usage:%d:%s:%s", 
            userId, usageType, LocalDateTime.now().truncatedTo(ChronoUnit.MINUTES));
        
        // Check daily limit
        int dailyUsage = getUsageCount(dailyKey);
        if (dailyUsage >= tier.getDailyLimit(usageType)) {
            return false; // Limit exceeded
        }
        
        // Check per-minute limit
        int minuteUsage = getUsageCount(minuteKey);
        if (minuteUsage >= tier.getPerMinuteLimit(usageType)) {
            return false; // Rate limit exceeded
        }
        
        // Record usage
        redisTemplate.opsForValue().increment(dailyKey);
        redisTemplate.opsForValue().increment(minuteKey);
        
        // Set expiration
        redisTemplate.expire(dailyKey, Duration.ofDays(1));
        redisTemplate.expire(minuteKey, Duration.ofMinutes(1));
        
        return true;
    }
    
    @Scheduled(cron = "0 0 * * * ?") // Hourly
    public void aggregateUsageStatistics() {
        // Aggregate usage data for analytics and billing
        List<UsageStatistic> statistics = calculateHourlyUsage();
        usageStatisticsRepository.saveAll(statistics);
    }
}
```

### Subscription Analytics
**Business Intelligence and Metrics:**
```java
@Service
public class SubscriptionAnalyticsService {
    
    public SubscriptionMetrics getSubscriptionMetrics(LocalDate startDate, LocalDate endDate) {
        return SubscriptionMetrics.builder()
            .totalSubscribers(getTotalSubscribers())
            .newSubscribers(getNewSubscribers(startDate, endDate))
            .churnedSubscribers(getChurnedSubscribers(startDate, endDate))
            .monthlyRecurringRevenue(getMonthlyRecurringRevenue())
            .averageRevenuePerUser(getAverageRevenuePerUser())
            .churnRate(calculateChurnRate(startDate, endDate))
            .customerLifetimeValue(calculateCustomerLifetimeValue())
            .tierDistribution(getTierDistribution())
            .build();
    }
    
    public List<User> getChurnRiskUsers() {
        // ML model to predict churn based on usage patterns
        return userRepository.findAll().stream()
            .filter(user -> {
                ChurnRiskScore score = calculateChurnRisk(user);
                return score.getScore() > 0.7; // High churn risk
            })
            .collect(Collectors.toList());
    }
    
    private ChurnRiskScore calculateChurnRisk(User user) {
        // Factors: usage decline, support tickets, feature engagement
        double usageScore = calculateUsageDeclineScore(user);
        double engagementScore = calculateEngagementScore(user);
        double supportScore = calculateSupportTicketScore(user);
        
        double combinedScore = (usageScore * 0.4) + (engagementScore * 0.4) + (supportScore * 0.2);
        
        return new ChurnRiskScore(combinedScore, getChurnFactors(user));
    }
}
```

### Promotional Campaign Management
**Discount and Coupon System:**
```java
@Entity
@Table(name = "promotional_campaigns")
public class PromotionalCampaign {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(unique = true)
    private String couponCode;
    
    @Enumerated(EnumType.STRING)
    private DiscountType discountType; // PERCENTAGE, FIXED_AMOUNT, FREE_TRIAL
    
    @Column(precision = 10, scale = 2)
    private BigDecimal discountValue;
    
    @Column(nullable = false)
    private LocalDateTime startDate;
    
    @Column(nullable = false)
    private LocalDateTime endDate;
    
    @Column
    private Integer maxUsages;
    
    @Column
    private Integer currentUsages = 0;
    
    @ElementCollection
    @Enumerated(EnumType.STRING)
    private Set<SubscriptionTier> applicableTiers;
    
    @Column
    private Boolean isActive = true;
}

@Service
public class PromotionalService {
    
    public DiscountValidationResult validateCoupon(String couponCode, Long userId, SubscriptionTier tier) {
        PromotionalCampaign campaign = campaignRepository.findByCouponCodeAndIsActive(couponCode, true)
            .orElse(null);
        
        if (campaign == null) {
            return DiscountValidationResult.invalid("Coupon code not found");
        }
        
        // Validation checks
        if (LocalDateTime.now().isBefore(campaign.getStartDate()) || 
            LocalDateTime.now().isAfter(campaign.getEndDate())) {
            return DiscountValidationResult.invalid("Coupon has expired");
        }
        
        if (campaign.getCurrentUsages() >= campaign.getMaxUsages()) {
            return DiscountValidationResult.invalid("Coupon usage limit reached");
        }
        
        if (!campaign.getApplicableTiers().contains(tier)) {
            return DiscountValidationResult.invalid("Coupon not applicable to selected tier");
        }
        
        BigDecimal discountAmount = calculateDiscount(campaign, tier);
        return DiscountValidationResult.valid(discountAmount, campaign);
    }
}
```

### Real-time Notifications
**Subscription Event Notifications:**
```java
@Component
public class SubscriptionNotificationService {
    
    @EventListener
    public void handleSubscriptionUpgrade(SubscriptionUpgradeEvent event) {
        NotificationPayload payload = NotificationPayload.builder()
            .type(NotificationType.SUBSCRIPTION_UPGRADED)
            .title("Subscription Upgraded!")
            .message(String.format("Welcome to %s! Enjoy your new features.", 
                event.getNewTier().getDisplayName()))
            .userId(event.getUserId())
            .build();
        
        sendMultiChannelNotification(event.getUserId(), payload);
    }
    
    @EventListener
    public void handlePaymentFailure(PaymentFailureEvent event) {
        NotificationPayload payload = NotificationPayload.builder()
            .type(NotificationType.PAYMENT_FAILED)
            .title("Payment Failed")
            .message("Please update your payment method to continue using TradeMaster.")
            .userId(event.getUserId())
            .actionUrl("/billing/payment-methods")
            .build();
        
        sendUrgentNotification(event.getUserId(), payload);
    }
    
    @Scheduled(cron = "0 0 9 * * ?") // Daily at 9 AM
    public void sendRenewalReminders() {
        LocalDateTime reminderDate = LocalDateTime.now().plusDays(3);
        
        List<Subscription> upcomingRenewals = subscriptionRepository
            .findByNextBillingDateBetween(
                reminderDate.minusHours(1), 
                reminderDate.plusHours(1)
            );
        
        upcomingRenewals.forEach(this::sendRenewalReminder);
    }
}
```

### Admin Dashboard Components
**Subscription Management Interface:**
```typescript
interface SubscriptionDashboardProps {
  adminUser: AdminUser;
}

const SubscriptionDashboard: React.FC<SubscriptionDashboardProps> = ({ adminUser }) => {
  const [metrics, setMetrics] = useState<SubscriptionMetrics>();
  const [churnRiskUsers, setChurnRiskUsers] = useState<User[]>([]);

  return (
    <DashboardLayout>
      <MetricsOverview metrics={metrics} />
      
      <Row>
        <Col span={12}>
          <RevenueChart data={metrics?.revenueData} />
        </Col>
        <Col span={12}>
          <TierDistributionChart data={metrics?.tierDistribution} />
        </Col>
      </Row>
      
      <ChurnRiskAlert users={churnRiskUsers} />
      
      <SubscriptionTable 
        subscriptions={subscriptions}
        onModifySubscription={handleSubscriptionModification}
      />
      
      <CampaignManagement 
        campaigns={campaigns}
        onCreateCampaign={handleCampaignCreation}
      />
    </DashboardLayout>
  );
};
```

### File Locations
**Subscription Management Structure:**
- `src/subscription/` - Main subscription management service
- `src/subscription/services/` - Business logic and billing integration
- `src/subscription/models/` - Subscription and billing data models
- `src/subscription/api/` - REST API endpoints for subscription management
- `src/subscription/billing/` - Payment processor integrations
- `src/subscription/analytics/` - Subscription analytics and reporting
- `src/subscription/notifications/` - Subscription event notifications
- `admin/src/components/subscription/` - Admin dashboard components

### Performance Requirements
**Subscription Service Performance Targets:**
- Feature access validation: <10ms for cached lookups
- Subscription tier lookup: <50ms from database
- Usage tracking: <5ms for Redis operations
- Billing event processing: <2 seconds for payment processing
- Analytics dashboard: <3 seconds for metrics loading

### Integration Requirements
**Service Integration:**
- Epic 1 Authentication: User identity and session management
- Story 1.3 API Gateway: Rate limiting based on subscription tiers
- All Platform Services: Feature access control and usage tracking
- Payment Processors: Stripe (global), Razorpay (India), PayPal (fallback)
- Email/SMS Services: Billing notifications and dunning management

## Testing

### Testing Standards
**Testing Requirements:** The Developer should implement comprehensive testing following these guidelines:

**Test File Locations:**
- Unit tests: `tests/unit/subscription/`
- Integration tests: `tests/integration/subscription/`
- Payment tests: `tests/integration/billing/`
- Analytics tests: `tests/unit/analytics/`

**Testing Frameworks and Patterns:**
- JUnit 5 for Java unit testing
- Spring Boot Test for integration testing
- TestContainers for database and Redis testing
- WireMock for payment processor integration testing
- Testcontainers for end-to-end subscription flow testing

**Specific Testing Requirements for This Story:**
- Test subscription tier access control across all platform services
- Verify billing integration with payment processors (Stripe, Razorpay)
- Test subscription lifecycle events and state transitions
- Validate usage tracking accuracy and rate limiting enforcement
- Test promotional campaign functionality and discount calculations
- Load testing for subscription service under high traffic volumes
- Test subscription data consistency across distributed services
- Validate subscription analytics accuracy and performance
- Test payment failure handling and dunning management
- Cross-service integration testing for feature access control

**Payment Integration Testing:**
- Test subscription creation and billing with test payment methods
- Verify webhook handling for payment events and failures
- Test proration calculations for subscription changes
- Validate refund processing and subscription modifications
- Test international payment scenarios and currency handling

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-08-05 | 1.0 | Initial story creation | Scrum Master (Bob) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by Dev Agent*

### Debug Log References  
*To be filled by Dev Agent*

### Completion Notes List
*To be filled by Dev Agent*

### File List
*To be filled by Dev Agent*

## QA Results

*This section will be populated by QA Agent after story implementation review*