# Story 2.1.3: Advanced Portfolio Analytics Frontend Implementation

## Story Overview

**Story ID:** 2.1.3  
**Epic:** 2.1 - Backend Implementation Gap Analysis  
**Story Title:** Frontend Implementation for Advanced Portfolio Analytics APIs  
**Priority:** High  
**Story Points:** 18  
**Status:** Ready for Development  

## Problem Statement

The TradeMaster portfolio service includes comprehensive backend APIs for advanced portfolio analytics, performance comparison, P&L breakdown, risk assessment, and optimization suggestions. However, the current frontend `PortfolioAnalytics.tsx` component only displays basic mock data and doesn't utilize these sophisticated backend capabilities, leaving significant analytical power unexposed to users.

## Business Value

**Primary Benefits:**
- Complete portfolio performance visibility with benchmark comparisons
- Detailed profit/loss analysis with attribution
- Proactive risk management through real-time assessment
- AI-powered portfolio optimization recommendations
- Professional-grade analytics for institutional traders

**User Impact:**
- Data-driven portfolio decisions
- Enhanced risk awareness and management
- Optimized portfolio performance through AI suggestions
- Comprehensive reporting for compliance and analysis

## User Stories

### As a Trader, I want comprehensive portfolio performance analysis
**Acceptance Criteria:**
- I can view portfolio performance vs. benchmarks over multiple timeframes
- I can see risk-adjusted returns (Sharpe ratio, Alpha, Beta)
- I can analyze portfolio attribution by sector, asset class, and holdings
- I can compare multiple portfolios side-by-side
- I can export performance reports for external analysis

### As a Portfolio Manager, I want detailed P&L breakdown and analysis
**Acceptance Criteria:**
- I can view realized vs. unrealized P&L with tax implications
- I can see P&L attribution by position, sector, and strategy
- I can analyze profit/loss over custom date ranges
- I can drill down into individual position contributions
- I can track trading costs and their impact on performance

### As a Risk Manager, I want real-time portfolio risk assessment
**Acceptance Criteria:**
- I can view current portfolio risk metrics (VaR, Expected Shortfall)
- I can see risk concentration by sector, geography, and asset class
- I can monitor risk limit breaches with alerts
- I can stress test portfolios against market scenarios
- I can track risk-adjusted performance over time

### As a Trader, I want AI-powered portfolio optimization
**Acceptance Criteria:**
- I can receive optimization suggestions based on risk tolerance
- I can see the impact of proposed changes before implementation
- I can optimize for different objectives (return, Sharpe ratio, ESG)
- I can implement optimization suggestions with one-click rebalancing
- I can track the performance of optimization recommendations

## Technical Specification

### Frontend Components to Implement

#### 1. Portfolio Performance Dashboard

**Component: `PortfolioPerformanceDashboard.tsx`**
```typescript
interface PerformanceMetrics {
  totalReturn: number;
  annualizedReturn: number;
  volatility: number;
  sharpeRatio: number;
  alpha: number;
  beta: number;
  maxDrawdown: number;
  calmarRatio: number;
}

interface BenchmarkComparison {
  benchmark: string;
  portfolioReturn: number;
  benchmarkReturn: number;
  trackingError: number;
  informationRatio: number;
}

export function PortfolioPerformanceDashboard({ portfolioId }: { portfolioId: string }) {
  const [performanceData, setPerformanceData] = useState<PerformanceComparison>();
  const [timeframe, setTimeframe] = useState('1Y');
  const [benchmark, setBenchmark] = useState('SPY');
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    fetchPerformanceData();
  }, [portfolioId, timeframe, benchmark]);

  const fetchPerformanceData = async () => {
    setLoading(true);
    try {
      const response = await portfolioService.getPerformanceComparison(
        portfolioId, 
        getDateRange(timeframe),
        benchmark
      );
      setPerformanceData(response);
    } catch (error) {
      handleError(error);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Performance Chart */}
      <PerformanceChart 
        data={performanceData?.chartData}
        benchmark={benchmark}
        loading={loading}
      />
      
      {/* Metrics Grid */}
      <MetricsGrid metrics={performanceData?.metrics} />
      
      {/* Attribution Analysis */}
      <AttributionAnalysis data={performanceData?.attribution} />
      
      {/* Benchmark Comparison */}
      <BenchmarkComparison data={performanceData?.comparison} />
    </div>
  );
}
```

**Service Integration:**
```typescript
// src/services/portfolioAnalyticsService.ts
export class PortfolioAnalyticsService {
  async getPerformanceComparison(
    portfolioId: string, 
    startDate: Date, 
    endDate: Date, 
    benchmark: string
  ): Promise<PerformanceComparison> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/performance`, {
      params: {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        benchmark
      }
    });
    return response.data;
  }

  async getDashboardData(portfolioId: string, period: string): Promise<AnalyticsDashboard> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/analytics`, {
      params: { period }
    });
    return response.data;
  }
}
```

#### 2. P&L Analysis Component

**Component: `PnLAnalysisComponent.tsx`**
```typescript
interface PnLBreakdown {
  totalPnL: number;
  realizedPnL: number;
  unrealizedPnL: number;
  dividends: number;
  tradingCosts: number;
  positionBreakdown: PositionPnL[];
  sectorBreakdown: SectorPnL[];
  dailyPnL: DailyPnL[];
}

interface PositionPnL {
  symbol: string;
  quantity: number;
  avgCost: number;
  currentValue: number;
  realizedPnL: number;
  unrealizedPnL: number;
  totalPnL: number;
  pnLPercent: number;
  contribution: number;
}

export function PnLAnalysisComponent({ portfolioId }: { portfolioId: string }) {
  const [pnlData, setPnlData] = useState<PnLBreakdown>();
  const [dateRange, setDateRange] = useState<DateRange>({
    start: subDays(new Date(), 30),
    end: new Date()
  });
  const [viewType, setViewType] = useState<'position' | 'sector' | 'daily'>('position');

  const fetchPnLData = async () => {
    try {
      const response = await portfolioService.getPnLBreakdown(
        portfolioId,
        dateRange.start,
        dateRange.end
      );
      setPnlData(response);
    } catch (error) {
      handleError(error);
    }
  };

  return (
    <div className="space-y-6">
      {/* P&L Summary Cards */}
      <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
        <PnLCard
          title="Total P&L"
          value={pnlData?.totalPnL}
          format="currency"
          className="col-span-2"
        />
        <PnLCard
          title="Realized"
          value={pnlData?.realizedPnL}
          format="currency"
        />
        <PnLCard
          title="Unrealized"
          value={pnlData?.unrealizedPnL}
          format="currency"
        />
      </div>

      {/* P&L Chart */}
      <PnLChart data={pnlData?.dailyPnL} />

      {/* View Selector */}
      <ViewSelector
        options={['position', 'sector', 'daily']}
        selected={viewType}
        onChange={setViewType}
      />

      {/* Breakdown Table */}
      {viewType === 'position' && (
        <PositionPnLTable data={pnlData?.positionBreakdown} />
      )}
      {viewType === 'sector' && (
        <SectorPnLTable data={pnlData?.sectorBreakdown} />
      )}
      {viewType === 'daily' && (
        <DailyPnLChart data={pnlData?.dailyPnL} />
      )}

      {/* Export Options */}
      <ExportOptions
        onExport={(format) => exportPnLReport(portfolioId, dateRange, format)}
      />
    </div>
  );
}
```

#### 3. Risk Assessment Dashboard

**Component: `RiskAssessmentDashboard.tsx`**
```typescript
interface RiskMetrics {
  valueAtRisk: {
    var95: number;
    var99: number;
    expectedShortfall: number;
  };
  concentration: {
    sectorConcentration: SectorRisk[];
    positionConcentration: PositionRisk[];
    geographicConcentration: GeographicRisk[];
  };
  correlation: {
    portfolioCorrelation: number;
    sectorCorrelations: CorrelationMatrix;
  };
  stressTesting: {
    scenarios: StressScenario[];
    worstCase: number;
    bestCase: number;
  };
}

export function RiskAssessmentDashboard({ portfolioId }: { portfolioId: string }) {
  const [riskData, setRiskData] = useState<RiskMetrics>();
  const [riskAlerts, setRiskAlerts] = useState<RiskAlert[]>([]);
  const [riskLimits, setRiskLimits] = useState<RiskLimitConfiguration>();

  const assessRisk = async () => {
    try {
      const [riskAssessment, alerts, limits] = await Promise.all([
        portfolioService.assessRisk(portfolioId, { includeStressTesting: true }),
        portfolioService.getRiskAlerts(portfolioId),
        portfolioService.getRiskLimits(portfolioId)
      ]);
      
      setRiskData(riskAssessment);
      setRiskAlerts(alerts);
      setRiskLimits(limits);
    } catch (error) {
      handleError(error);
    }
  };

  return (
    <div className="space-y-6">
      {/* Risk Alerts */}
      {riskAlerts.length > 0 && (
        <RiskAlertsPanel alerts={riskAlerts} />
      )}

      {/* Risk Metrics Overview */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <VaRCard data={riskData?.valueAtRisk} />
        <ConcentrationCard data={riskData?.concentration} />
        <CorrelationCard data={riskData?.correlation} />
      </div>

      {/* Risk Limit Configuration */}
      <RiskLimitsConfiguration
        limits={riskLimits}
        onUpdate={updateRiskLimits}
      />

      {/* Concentration Analysis */}
      <ConcentrationAnalysis data={riskData?.concentration} />

      {/* Stress Testing */}
      <StressTestingPanel data={riskData?.stressTesting} />

      {/* Risk Monitoring Chart */}
      <RiskTimeSeriesChart portfolioId={portfolioId} />
    </div>
  );
}
```

#### 4. Portfolio Optimization Component

**Component: `PortfolioOptimizationComponent.tsx`**
```typescript
interface OptimizationRequest {
  objective: 'SHARPE_RATIO' | 'MIN_VARIANCE' | 'MAX_RETURN' | 'ESG_SCORE';
  constraints: {
    maxPositionWeight?: number;
    maxSectorWeight?: number;
    minPositions?: number;
    maxPositions?: number;
    allowShortSelling?: boolean;
  };
  riskTolerance: number;
}

interface OptimizationSuggestion {
  id: string;
  objective: string;
  currentMetrics: PortfolioMetrics;
  optimizedMetrics: PortfolioMetrics;
  suggestions: RebalancingSuggestion[];
  expectedImprovement: {
    returnImprovement: number;
    riskReduction: number;
    sharpeImprovement: number;
  };
  implementationCost: number;
}

export function PortfolioOptimizationComponent({ portfolioId }: { portfolioId: string }) {
  const [optimizationRequest, setOptimizationRequest] = useState<OptimizationRequest>({
    objective: 'SHARPE_RATIO',
    constraints: {},
    riskTolerance: 0.5
  });
  const [suggestions, setSuggestions] = useState<OptimizationSuggestion[]>([]);
  const [selectedSuggestion, setSelectedSuggestion] = useState<OptimizationSuggestion>();
  const [loading, setLoading] = useState(false);

  const runOptimization = async () => {
    setLoading(true);
    try {
      const response = await portfolioService.getOptimizationSuggestions(
        portfolioId,
        optimizationRequest.objective
      );
      setSuggestions(response);
    } catch (error) {
      handleError(error);
    } finally {
      setLoading(false);
    }
  };

  const implementOptimization = async (suggestionId: string) => {
    try {
      await portfolioService.implementOptimization(portfolioId, suggestionId);
      showSuccess('Optimization implemented successfully');
      // Refresh portfolio data
    } catch (error) {
      handleError(error);
    }
  };

  return (
    <div className="space-y-6">
      {/* Optimization Configuration */}
      <OptimizationConfiguration
        request={optimizationRequest}
        onChange={setOptimizationRequest}
        onRun={runOptimization}
        loading={loading}
      />

      {/* Optimization Results */}
      {suggestions.length > 0 && (
        <OptimizationResults
          suggestions={suggestions}
          onSelect={setSelectedSuggestion}
          selected={selectedSuggestion}
        />
      )}

      {/* Implementation Preview */}
      {selectedSuggestion && (
        <ImplementationPreview
          suggestion={selectedSuggestion}
          onImplement={() => implementOptimization(selectedSuggestion.id)}
        />
      )}

      {/* Optimization History */}
      <OptimizationHistory portfolioId={portfolioId} />
    </div>
  );
}
```

#### 5. Portfolio Rebalancing Interface

**Component: `PortfolioRebalancingInterface.tsx`**
```typescript
interface RebalancingStrategy {
  type: 'TARGET_ALLOCATION' | 'RISK_PARITY' | 'EQUAL_WEIGHT' | 'MOMENTUM';
  parameters: Record<string, any>;
  targetAllocations?: Record<string, number>;
}

interface RebalancingPreview {
  currentAllocations: Record<string, number>;
  targetAllocations: Record<string, number>;
  trades: RebalancingTrade[];
  estimatedCosts: number;
  taxImplications: number;
  expectedImpact: {
    riskChange: number;
    returnChange: number;
  };
}

export function PortfolioRebalancingInterface({ portfolioId }: { portfolioId: string }) {
  const [strategy, setStrategy] = useState<RebalancingStrategy>({
    type: 'TARGET_ALLOCATION',
    parameters: {}
  });
  const [preview, setPreview] = useState<RebalancingPreview>();
  const [rebalancing, setRebalancing] = useState(false);

  const generatePreview = async () => {
    try {
      const response = await portfolioService.getRebalancingPreview(portfolioId, strategy);
      setPreview(response);
    } catch (error) {
      handleError(error);
    }
  };

  const executeRebalancing = async () => {
    setRebalancing(true);
    try {
      const response = await portfolioService.rebalancePortfolio(portfolioId, strategy.type);
      showSuccess('Rebalancing initiated successfully');
      // Navigate to execution monitoring
    } catch (error) {
      handleError(error);
    } finally {
      setRebalancing(false);
    }
  };

  return (
    <div className="space-y-6">
      {/* Strategy Selection */}
      <StrategySelector
        strategy={strategy}
        onChange={setStrategy}
      />

      {/* Target Allocation Editor */}
      {strategy.type === 'TARGET_ALLOCATION' && (
        <TargetAllocationEditor
          portfolioId={portfolioId}
          allocations={strategy.targetAllocations}
          onChange={(allocations) => 
            setStrategy(prev => ({ ...prev, targetAllocations: allocations }))
          }
        />
      )}

      {/* Preview Button */}
      <Button onClick={generatePreview} variant="outline">
        Generate Rebalancing Preview
      </Button>

      {/* Rebalancing Preview */}
      {preview && (
        <RebalancingPreview
          preview={preview}
          onExecute={executeRebalancing}
          executing={rebalancing}
        />
      )}

      {/* Rebalancing History */}
      <RebalancingHistory portfolioId={portfolioId} />
    </div>
  );
}
```

### Enhanced Portfolio Analytics Service

```typescript
// src/services/portfolioAnalyticsService.ts
export class PortfolioAnalyticsService {
  async getPerformanceComparison(
    portfolioId: string,
    startDate: Date,
    endDate: Date,
    benchmark: string
  ): Promise<PerformanceComparison> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/performance`, {
      params: {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString(),
        benchmark
      }
    });
    return response.data;
  }

  async getPnLBreakdown(
    portfolioId: string,
    startDate: Date,
    endDate: Date
  ): Promise<PnLBreakdown> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/pnl`, {
      params: {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString()
      }
    });
    return response.data;
  }

  async assessRisk(
    portfolioId: string,
    request: RiskAssessmentRequest
  ): Promise<RiskMetrics> {
    const response = await apiClient.post(`/api/v1/portfolios/${portfolioId}/risk/assess`, request);
    return response.data;
  }

  async getRiskAlerts(portfolioId: string, severity?: string): Promise<RiskAlert[]> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/risk/alerts`, {
      params: { severity }
    });
    return response.data;
  }

  async configureRiskLimits(
    portfolioId: string,
    config: RiskLimitConfiguration
  ): Promise<RiskLimitConfiguration> {
    const response = await apiClient.put(`/api/v1/portfolios/${portfolioId}/risk/limits`, config);
    return response.data;
  }

  async getOptimizationSuggestions(
    portfolioId: string,
    objective: string
  ): Promise<OptimizationSuggestion[]> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/optimize`, {
      params: { objective }
    });
    return response.data;
  }

  async rebalancePortfolio(
    portfolioId: string,
    strategy: string
  ): Promise<RebalancingResult> {
    const response = await apiClient.post(`/api/v1/portfolios/${portfolioId}/rebalance`, {
      strategy
    });
    return response.data;
  }

  async getDashboardData(portfolioId: string, period: string): Promise<AnalyticsDashboard> {
    const response = await apiClient.get(`/api/v1/portfolios/${portfolioId}/analytics`, {
      params: { period }
    });
    return response.data;
  }
}
```

### Chart Components for Analytics

```typescript
// src/components/charts/PerformanceChart.tsx
export function PerformanceChart({ 
  data, 
  benchmark, 
  loading 
}: {
  data: ChartDataPoint[];
  benchmark: string;
  loading: boolean;
}) {
  if (loading) {
    return <ChartSkeleton />;
  }

  return (
    <div className="glass-card rounded-2xl p-6">
      <div className="flex items-center justify-between mb-6">
        <h3 className="text-lg font-bold text-white">Portfolio vs {benchmark}</h3>
        <div className="flex space-x-2">
          <Button variant="outline" size="sm">1M</Button>
          <Button variant="outline" size="sm">3M</Button>
          <Button variant="outline" size="sm">1Y</Button>
          <Button variant="outline" size="sm">3Y</Button>
        </div>
      </div>
      
      <ResponsiveContainer width="100%" height={400}>
        <LineChart data={data}>
          <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
          <XAxis dataKey="date" stroke="#9CA3AF" />
          <YAxis stroke="#9CA3AF" />
          <Tooltip 
            contentStyle={{ 
              backgroundColor: '#1F2937', 
              border: '1px solid #374151',
              borderRadius: '8px'
            }}
          />
          <Legend />
          <Line 
            type="monotone" 
            dataKey="portfolioValue" 
            stroke="#8B5CF6" 
            strokeWidth={2}
            name="Portfolio"
          />
          <Line 
            type="monotone" 
            dataKey="benchmarkValue" 
            stroke="#10B981" 
            strokeWidth={2}
            name={benchmark}
          />
        </LineChart>
      </ResponsiveContainer>
    </div>
  );
}
```

## Testing Requirements

### Unit Tests
- Portfolio performance calculation accuracy
- P&L breakdown component rendering
- Risk metric calculation validation
- Optimization suggestion processing
- Chart data transformation

### Integration Tests
- End-to-end portfolio analytics workflow
- Real-time risk monitoring functionality
- Optimization implementation process
- Report generation and export
- Multi-portfolio comparison features

### User Experience Tests
- Analytics dashboard load times (<2 seconds)
- Chart rendering performance
- Real-time data update responsiveness
- Mobile responsive design validation

## Definition of Done

- [ ] All portfolio analytics APIs integrated into frontend
- [ ] Real-time risk monitoring implemented
- [ ] Portfolio optimization interface functional
- [ ] P&L analysis with detailed breakdowns
- [ ] Performance comparison with benchmarks
- [ ] Report export functionality
- [ ] Mobile-responsive design
- [ ] Comprehensive test coverage
- [ ] Performance benchmarks met

## Dependencies

### Technical Dependencies
- Chart.js or D3.js for advanced visualizations
- Date picker library for range selection
- Export library for report generation
- Real-time WebSocket connections

### Story Dependencies
- Story 2.1.1 (Authentication for user-specific analytics)
- Story 2.1.2 (Market data for benchmark comparisons)
- Portfolio service backend APIs
- Risk calculation engine

## Success Metrics

### Technical Metrics
- Analytics dashboard load time <2 seconds
- Chart rendering time <500ms
- Real-time update latency <100ms
- Report generation time <5 seconds

### Business Metrics
- Portfolio analytics usage adoption >80%
- Risk management feature engagement >60%
- Optimization suggestion implementation rate >40%
- User satisfaction with analytics tools >4.5/5

## Implementation Plan

### Week 1: Performance Analytics
- Implement performance dashboard
- Add benchmark comparison charts
- Create metrics grid and attribution analysis

### Week 2: Risk Management
- Build risk assessment dashboard
- Add risk alerts and monitoring
- Implement risk limit configuration

### Week 3: P&L and Optimization
- Create detailed P&L analysis component
- Build portfolio optimization interface
- Add rebalancing functionality

### Week 4: Integration and Testing
- Complete all API integrations
- Comprehensive testing and optimization
- Performance tuning and deployment