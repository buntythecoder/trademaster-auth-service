# Story 2.1.5: Document & Profile Management Integration

## Story Overview

**Story ID:** 2.1.5  
**Epic:** 2.1 - Backend Implementation Gap Analysis  
**Story Title:** Frontend Integration for Document & User Profile Management APIs  
**Priority:** Medium  
**Story Points:** 10  
**Status:** Ready for Development  

## Problem Statement

The TradeMaster user-profile-service provides comprehensive backend APIs for document management, KYC verification, user preferences, and broker configuration. However, the current frontend components (`KYCDocuments.tsx`, `ProfileDashboard.tsx`) only display mock data and don't utilize these robust backend capabilities, preventing users from accessing critical profile management features.

## Business Value

**Primary Benefits:**
- Complete KYC document management and verification workflow
- Comprehensive user profile configuration and preferences
- Broker integration and trading preferences management
- Document storage and retrieval for compliance
- Enhanced user experience through personalized settings

**User Impact:**
- Streamlined onboarding through digital document upload
- Personalized trading experience through preferences
- Compliance readiness through proper documentation
- Efficient broker integration and management

## User Stories

### As a New User, I want to complete KYC verification
**Acceptance Criteria:**
- I can upload required identity and address documents
- I can track the verification status of my documents
- I can receive notifications about verification progress
- I can re-upload documents if they are rejected
- I can view verification requirements and guidelines

### As a Trader, I want to manage my trading preferences
**Acceptance Criteria:**
- I can configure default order settings and risk parameters
- I can set notification preferences for various events
- I can choose my preferred trading segments and markets
- I can customize my dashboard layout and widgets
- I can save and apply different preference profiles

### As a Trader, I want to configure multiple brokers
**Acceptance Criteria:**
- I can add and manage multiple broker accounts
- I can configure API credentials securely
- I can set broker-specific preferences and settings
- I can test broker connections and configurations
- I can view broker-specific features and limitations

### As a User, I want to manage my personal information
**Acceptance Criteria:**
- I can update my personal and contact information
- I can change my password and security settings
- I can view my account activity and login history
- I can download my data for personal records
- I can configure privacy and data sharing preferences

## Technical Specification

### Frontend Components to Implement

#### 1. Enhanced KYC Document Management

**Component: `KYCDocumentManager.tsx`**
```typescript
interface DocumentUploadRequest {
  documentType: DocumentType;
  file: File;
  metadata?: {
    expirationDate?: Date;
    issueDate?: Date;
    documentNumber?: string;
    issuingAuthority?: string;
  };
}

interface DocumentResponse {
  id: string;
  documentType: DocumentType;
  filename: string;
  uploadDate: Date;
  verificationStatus: VerificationStatus;
  rejectionReason?: string;
  expirationDate?: Date;
  downloadUrl?: string;
}

export function KYCDocumentManager() {
  const [documents, setDocuments] = useState<DocumentResponse[]>([]);
  const [uploadingDocuments, setUploadingDocuments] = useState<Map<string, number>>(new Map());
  const [verificationStatus, setVerificationStatus] = useState<VerificationStatus>('PENDING');

  const fetchDocuments = async () => {
    try {
      const response = await userProfileService.getDocuments();
      setDocuments(response);
      updateOverallVerificationStatus(response);
    } catch (error) {
      handleError(error);
    }
  };

  const uploadDocument = async (uploadRequest: DocumentUploadRequest) => {
    const uploadId = generateUploadId();
    setUploadingDocuments(prev => new Map(prev.set(uploadId, 0)));

    try {
      const response = await userProfileService.uploadDocument(uploadRequest, {
        onProgress: (progress) => {
          setUploadingDocuments(prev => new Map(prev.set(uploadId, progress)));
        }
      });

      setDocuments(prev => [...prev, response]);
      showSuccess('Document uploaded successfully');
    } catch (error) {
      handleError(error);
    } finally {
      setUploadingDocuments(prev => {
        const newMap = new Map(prev);
        newMap.delete(uploadId);
        return newMap;
      });
    }
  };

  const deleteDocument = async (documentId: string) => {
    try {
      await userProfileService.deleteDocument(documentId);
      setDocuments(prev => prev.filter(doc => doc.id !== documentId));
      showSuccess('Document deleted successfully');
    } catch (error) {
      handleError(error);
    }
  };

  return (
    <div className="space-y-6">
      {/* Verification Status Header */}
      <div className="glass-card rounded-2xl p-6">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-bold text-white mb-2">KYC Verification</h2>
            <VerificationStatusBadge status={verificationStatus} />
          </div>
          <div className="text-right">
            <div className="text-2xl font-bold text-white">
              {documents.filter(doc => doc.verificationStatus === 'VERIFIED').length} / {getRequiredDocumentCount()}
            </div>
            <div className="text-sm text-slate-400">Documents Verified</div>
          </div>
        </div>
      </div>

      {/* Document Categories */}
      <div className="grid gap-6">
        {getDocumentCategories().map((category) => (
          <DocumentCategory
            key={category.type}
            category={category}
            documents={documents.filter(doc => doc.documentType === category.type)}
            onUpload={(file, metadata) => uploadDocument({
              documentType: category.type,
              file,
              metadata
            })}
            onDelete={deleteDocument}
            uploading={Array.from(uploadingDocuments.entries()).some(([id, progress]) => 
              progress < 100 && id.includes(category.type)
            )}
          />
        ))}
      </div>

      {/* Verification Progress */}
      <VerificationProgress documents={documents} />
    </div>
  );
}
```

#### 2. Comprehensive User Preferences

**Component: `UserPreferencesManager.tsx`**
```typescript
interface UserPreferences {
  trading: TradingPreferences;
  notifications: NotificationSettings;
  display: DisplaySettings;
  privacy: PrivacySettings;
  broker: BrokerConfiguration[];
}

interface TradingPreferences {
  defaultOrderType: OrderType;
  defaultTimeInForce: TimeInForce;
  defaultOrderValidity: OrderValidity;
  riskLevel: RiskLevel;
  tradingSegments: TradingSegment[];
  autoSquareOff: boolean;
  confirmationRequired: boolean;
}

export function UserPreferencesManager() {
  const [preferences, setPreferences] = useState<UserPreferences>();
  const [activeTab, setActiveTab] = useState<'trading' | 'notifications' | 'display' | 'privacy'>('trading');
  const [saving, setSaving] = useState(false);
  const [hasChanges, setHasChanges] = useState(false);

  const fetchPreferences = async () => {
    try {
      const response = await userProfileService.getPreferences();
      setPreferences(response);
    } catch (error) {
      handleError(error);
    }
  };

  const savePreferences = async () => {
    if (!preferences) return;
    
    setSaving(true);
    try {
      await userProfileService.updatePreferences(preferences);
      setHasChanges(false);
      showSuccess('Preferences saved successfully');
    } catch (error) {
      handleError(error);
    } finally {
      setSaving(false);
    }
  };

  const updatePreferences = <K extends keyof UserPreferences>(
    section: K,
    updates: Partial<UserPreferences[K]>
  ) => {
    setPreferences(prev => prev ? {
      ...prev,
      [section]: { ...prev[section], ...updates }
    } : undefined);
    setHasChanges(true);
  };

  return (
    <div className="space-y-6">
      {/* Preferences Header */}
      <div className="glass-card rounded-2xl p-6">
        <div className="flex items-center justify-between">
          <h2 className="text-xl font-bold text-white">User Preferences</h2>
          <div className="flex items-center space-x-3">
            {hasChanges && (
              <span className="text-sm text-amber-400">Unsaved changes</span>
            )}
            <Button
              onClick={savePreferences}
              disabled={!hasChanges || saving}
              className="px-6"
            >
              {saving ? 'Saving...' : 'Save Changes'}
            </Button>
          </div>
        </div>
      </div>

      {/* Preferences Tabs */}
      <div className="glass-card rounded-2xl p-6">
        <div className="flex space-x-1 mb-6">
          {[
            { key: 'trading', label: 'Trading', icon: TrendingUp },
            { key: 'notifications', label: 'Notifications', icon: Bell },
            { key: 'display', label: 'Display', icon: Monitor },
            { key: 'privacy', label: 'Privacy', icon: Shield }
          ].map(({ key, label, icon: Icon }) => (
            <button
              key={key}
              onClick={() => setActiveTab(key as any)}
              className={`flex items-center space-x-2 px-4 py-2 rounded-xl transition-all ${
                activeTab === key
                  ? 'bg-purple-500/20 text-purple-400 border border-purple-500/50'
                  : 'text-slate-400 hover:text-white hover:bg-slate-700/50'
              }`}
            >
              <Icon className="w-4 h-4" />
              <span>{label}</span>
            </button>
          ))}
        </div>

        {/* Tab Content */}
        {activeTab === 'trading' && preferences && (
          <TradingPreferencesTab
            preferences={preferences.trading}
            onChange={(updates) => updatePreferences('trading', updates)}
          />
        )}

        {activeTab === 'notifications' && preferences && (
          <NotificationPreferencesTab
            preferences={preferences.notifications}
            onChange={(updates) => updatePreferences('notifications', updates)}
          />
        )}

        {activeTab === 'display' && preferences && (
          <DisplayPreferencesTab
            preferences={preferences.display}
            onChange={(updates) => updatePreferences('display', updates)}
          />
        )}

        {activeTab === 'privacy' && preferences && (
          <PrivacyPreferencesTab
            preferences={preferences.privacy}
            onChange={(updates) => updatePreferences('privacy', updates)}
          />
        )}
      </div>
    </div>
  );
}
```

#### 3. Broker Configuration Manager

**Component: `BrokerConfigurationManager.tsx`**
```typescript
interface BrokerConfiguration {
  id: string;
  brokerName: string;
  brokerType: string;
  apiCredentials: {
    apiKey: string;
    apiSecret: string;
    userId?: string;
    password?: string;
  };
  isActive: boolean;
  lastConnection?: Date;
  connectionStatus: 'CONNECTED' | 'DISCONNECTED' | 'ERROR';
  supportedFeatures: string[];
  tradingSegments: TradingSegment[];
}

export function BrokerConfigurationManager() {
  const [brokers, setBrokers] = useState<BrokerConfiguration[]>([]);
  const [showAddBroker, setShowAddBroker] = useState(false);
  const [testingConnections, setTestingConnections] = useState<Set<string>>(new Set());

  const fetchBrokers = async () => {
    try {
      const response = await userProfileService.getBrokerConfigurations();
      setBrokers(response);
    } catch (error) {
      handleError(error);
    }
  };

  const addBroker = async (brokerConfig: Omit<BrokerConfiguration, 'id'>) => {
    try {
      const response = await userProfileService.addBrokerConfiguration(brokerConfig);
      setBrokers(prev => [...prev, response]);
      setShowAddBroker(false);
      showSuccess('Broker added successfully');
    } catch (error) {
      handleError(error);
    }
  };

  const testBrokerConnection = async (brokerId: string) => {
    setTestingConnections(prev => new Set(prev.add(brokerId)));
    
    try {
      const result = await userProfileService.testBrokerConnection(brokerId);
      setBrokers(prev => prev.map(broker => 
        broker.id === brokerId 
          ? { ...broker, connectionStatus: result.success ? 'CONNECTED' : 'ERROR' }
          : broker
      ));
      
      if (result.success) {
        showSuccess('Broker connection successful');
      } else {
        showError(`Connection failed: ${result.error}`);
      }
    } catch (error) {
      handleError(error);
    } finally {
      setTestingConnections(prev => {
        const newSet = new Set(prev);
        newSet.delete(brokerId);
        return newSet;
      });
    }
  };

  const removeBroker = async (brokerId: string) => {
    try {
      await userProfileService.removeBrokerConfiguration(brokerId);
      setBrokers(prev => prev.filter(broker => broker.id !== brokerId));
      showSuccess('Broker removed successfully');
    } catch (error) {
      handleError(error);
    }
  };

  return (
    <div className="space-y-6">
      {/* Broker Management Header */}
      <div className="glass-card rounded-2xl p-6">
        <div className="flex items-center justify-between">
          <div>
            <h2 className="text-xl font-bold text-white mb-2">Broker Configuration</h2>
            <p className="text-slate-400">Manage your broker accounts and trading connections</p>
          </div>
          <Button
            onClick={() => setShowAddBroker(true)}
            className="flex items-center space-x-2"
          >
            <Plus className="w-4 h-4" />
            <span>Add Broker</span>
          </Button>
        </div>
      </div>

      {/* Broker List */}
      <div className="space-y-4">
        {brokers.map((broker) => (
          <BrokerCard
            key={broker.id}
            broker={broker}
            onTest={() => testBrokerConnection(broker.id)}
            onRemove={() => removeBroker(broker.id)}
            testing={testingConnections.has(broker.id)}
          />
        ))}
        
        {brokers.length === 0 && (
          <EmptyState
            title="No Brokers Configured"
            description="Add your first broker to start trading"
            action={
              <Button onClick={() => setShowAddBroker(true)}>
                Add Broker
              </Button>
            }
          />
        )}
      </div>

      {/* Add Broker Modal */}
      {showAddBroker && (
        <AddBrokerModal
          onAdd={addBroker}
          onClose={() => setShowAddBroker(false)}
        />
      )}
    </div>
  );
}
```

#### 4. Profile Dashboard Integration

**Component: `EnhancedProfileDashboard.tsx`**
```typescript
interface UserProfile {
  personalInfo: PersonalInformation;
  kycInfo: KYCInformation;
  preferences: UserPreferences;
  documents: DocumentResponse[];
  brokers: BrokerConfiguration[];
  accountStatus: {
    verificationStatus: VerificationStatus;
    tradingEnabled: boolean;
    riskProfile: RiskProfile;
    accountLevel: string;
  };
}

export function EnhancedProfileDashboard() {
  const [profile, setProfile] = useState<UserProfile>();
  const [loading, setLoading] = useState(true);
  const [activeSection, setActiveSection] = useState<'overview' | 'documents' | 'preferences' | 'brokers'>('overview');

  const fetchProfile = async () => {
    setLoading(true);
    try {
      const [profileData, documents, preferences, brokers] = await Promise.all([
        userProfileService.getProfile(),
        userProfileService.getDocuments(),
        userProfileService.getPreferences(),
        userProfileService.getBrokerConfigurations()
      ]);

      setProfile({
        ...profileData,
        documents,
        preferences,
        brokers
      });
    } catch (error) {
      handleError(error);
    } finally {
      setLoading(false);
    }
  };

  useEffect(() => {
    fetchProfile();
  }, []);

  if (loading) {
    return <ProfileSkeleton />;
  }

  return (
    <div className="space-y-6">
      {/* Profile Header */}
      <div className="glass-card rounded-2xl p-6">
        <div className="flex items-center space-x-6">
          <div className="w-20 h-20 rounded-full bg-gradient-to-r from-purple-500 to-cyan-500 flex items-center justify-center">
            <span className="text-2xl font-bold text-white">
              {getInitials(profile?.personalInfo.firstName, profile?.personalInfo.lastName)}
            </span>
          </div>
          <div className="flex-1">
            <h1 className="text-2xl font-bold text-white">
              {profile?.personalInfo.firstName} {profile?.personalInfo.lastName}
            </h1>
            <p className="text-slate-400">{profile?.personalInfo.email}</p>
            <div className="flex items-center space-x-4 mt-2">
              <VerificationStatusBadge status={profile?.accountStatus.verificationStatus} />
              <AccountLevelBadge level={profile?.accountStatus.accountLevel} />
              <TradingStatusBadge enabled={profile?.accountStatus.tradingEnabled} />
            </div>
          </div>
          <div className="flex items-center space-x-3">
            <Button variant="outline">Edit Profile</Button>
            <Button>Account Settings</Button>
          </div>
        </div>
      </div>

      {/* Navigation Tabs */}
      <div className="glass-card rounded-2xl p-6">
        <div className="flex space-x-1 mb-6">
          {[
            { key: 'overview', label: 'Overview', icon: User },
            { key: 'documents', label: 'Documents', icon: FileText },
            { key: 'preferences', label: 'Preferences', icon: Settings },
            { key: 'brokers', label: 'Brokers', icon: Building }
          ].map(({ key, label, icon: Icon }) => (
            <button
              key={key}
              onClick={() => setActiveSection(key as any)}
              className={`flex items-center space-x-2 px-4 py-2 rounded-xl transition-all ${
                activeSection === key
                  ? 'bg-purple-500/20 text-purple-400 border border-purple-500/50'
                  : 'text-slate-400 hover:text-white hover:bg-slate-700/50'
              }`}
            >
              <Icon className="w-4 h-4" />
              <span>{label}</span>
            </button>
          ))}
        </div>

        {/* Section Content */}
        {activeSection === 'overview' && (
          <ProfileOverview profile={profile} />
        )}

        {activeSection === 'documents' && (
          <KYCDocumentManager />
        )}

        {activeSection === 'preferences' && (
          <UserPreferencesManager />
        )}

        {activeSection === 'brokers' && (
          <BrokerConfigurationManager />
        )}
      </div>
    </div>
  );
}
```

### Enhanced User Profile Service

```typescript
// src/services/userProfileService.ts
export class UserProfileService {
  async getProfile(): Promise<UserProfile> {
    const response = await apiClient.get('/api/v1/profile');
    return response.data;
  }

  async updateProfile(updates: Partial<UserProfile>): Promise<UserProfile> {
    const response = await apiClient.put('/api/v1/profile', updates);
    return response.data;
  }

  async getDocuments(): Promise<DocumentResponse[]> {
    const response = await apiClient.get('/api/v1/profile/documents');
    return response.data;
  }

  async uploadDocument(
    request: DocumentUploadRequest,
    options?: { onProgress?: (progress: number) => void }
  ): Promise<DocumentResponse> {
    const formData = new FormData();
    formData.append('file', request.file);
    formData.append('documentType', request.documentType);
    if (request.metadata) {
      formData.append('metadata', JSON.stringify(request.metadata));
    }

    const response = await apiClient.post('/api/v1/profile/documents', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      onUploadProgress: (progressEvent) => {
        if (options?.onProgress && progressEvent.total) {
          const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
          options.onProgress(progress);
        }
      }
    });
    return response.data;
  }

  async deleteDocument(documentId: string): Promise<void> {
    await apiClient.delete(`/api/v1/profile/documents/${documentId}`);
  }

  async getPreferences(): Promise<UserPreferences> {
    const response = await apiClient.get('/api/v1/profile/preferences');
    return response.data;
  }

  async updatePreferences(preferences: UserPreferences): Promise<UserPreferences> {
    const response = await apiClient.put('/api/v1/profile/preferences', preferences);
    return response.data;
  }

  async getBrokerConfigurations(): Promise<BrokerConfiguration[]> {
    const response = await apiClient.get('/api/v1/profile/brokers');
    return response.data;
  }

  async addBrokerConfiguration(config: Omit<BrokerConfiguration, 'id'>): Promise<BrokerConfiguration> {
    const response = await apiClient.post('/api/v1/profile/brokers', config);
    return response.data;
  }

  async updateBrokerConfiguration(
    brokerId: string, 
    updates: Partial<BrokerConfiguration>
  ): Promise<BrokerConfiguration> {
    const response = await apiClient.put(`/api/v1/profile/brokers/${brokerId}`, updates);
    return response.data;
  }

  async removeBrokerConfiguration(brokerId: string): Promise<void> {
    await apiClient.delete(`/api/v1/profile/brokers/${brokerId}`);
  }

  async testBrokerConnection(brokerId: string): Promise<{ success: boolean; error?: string }> {
    const response = await apiClient.post(`/api/v1/profile/brokers/${brokerId}/test`);
    return response.data;
  }

  async exportUserData(): Promise<Blob> {
    const response = await apiClient.get('/api/v1/profile/export', {
      responseType: 'blob'
    });
    return response.data;
  }
}
```

## Testing Requirements

### Unit Tests
- Document upload and validation
- Preference saving and retrieval
- Broker configuration management
- Profile data transformation
- Error handling for all scenarios

### Integration Tests
- End-to-end KYC workflow
- Complete profile management flow
- Broker connection testing
- Document verification process
- Preference synchronization

### Security Tests
- Document storage security
- Credential encryption validation
- Access control verification
- Data privacy compliance

## Definition of Done

- [ ] KYC document management fully functional
- [ ] User preferences system integrated
- [ ] Broker configuration interface complete
- [ ] Profile dashboard with all sections
- [ ] Document upload with progress tracking
- [ ] Secure credential management
- [ ] Data export functionality
- [ ] Mobile responsive design
- [ ] Comprehensive test coverage

## Dependencies

### Technical Dependencies
- File upload library with progress tracking
- Form validation library
- Secure credential storage
- Document viewer component

### Story Dependencies
- Story 2.1.1 (Authentication for profile access)
- User profile service backend APIs
- Document storage infrastructure

## Success Metrics

### Technical Metrics
- Document upload success rate >99%
- Profile update response time <500ms
- Broker connection test time <2 seconds
- Document verification processing <24 hours

### Business Metrics
- KYC completion rate >90%
- Profile completion rate >95%
- Broker integration adoption >70%
- User satisfaction with profile features >4.5/5

## Implementation Plan

### Week 1: Document Management
- Implement KYC document upload interface
- Add document verification status tracking
- Create document gallery and management

### Week 2: User Preferences
- Build comprehensive preferences interface
- Add preference categories and settings
- Implement preference persistence

### Week 3: Broker Configuration
- Create broker management interface
- Add broker connection testing
- Implement secure credential storage

### Week 4: Integration and Testing
- Complete profile dashboard integration
- Comprehensive testing and validation
- Performance optimization and deployment