# Story 2.1.2: Market Data Service Integration

## Story Overview

**Story ID:** 2.1.2  
**Epic:** 2.1 - Backend Implementation Gap Analysis  
**Story Title:** Complete Market Data Service Backend Implementation  
**Priority:** High  
**Story Points:** 21  
**Status:** Ready for Development  

## Problem Statement

The TradeMaster frontend includes sophisticated market data components (`MarketScanner.tsx`, `EconomicCalendar.tsx`, `MarketNewsTicker.tsx`, `PriceAlerts.tsx`, `AdvancedChart.tsx`, `SymbolLookup.tsx`) that currently operate with mock data. While the existing market-data-service provides basic real-time price feeds, it lacks critical features required for advanced market analysis and trading decisions.

## Business Value

**Primary Benefits:**
- Real-time market scanning and filtering capabilities
- Comprehensive economic calendar integration
- Live news feed with sentiment analysis
- Advanced price alerting system
- Professional-grade charting with technical indicators

**User Impact:**
- Data-driven trading decisions
- Competitive advantage through advanced market analysis
- Reduced research time through integrated information
- Proactive trading through intelligent alerts

## User Stories

### As a Trader, I want to scan markets for trading opportunities
**Acceptance Criteria:**
- I can filter stocks by price, volume, and technical indicators
- I can create custom screeners with multiple criteria
- I can save and share my screening configurations
- I receive real-time updates as stocks meet my criteria
- I can export screening results for further analysis

### As a Trader, I want to stay informed about economic events
**Acceptance Criteria:**
- I can view upcoming economic events with impact levels
- I can filter events by country, impact, and relevance
- I receive notifications for high-impact events
- I can see historical event data and market reactions
- I can correlate events with price movements

### As a Trader, I want real-time market news and sentiment
**Acceptance Criteria:**
- I can view latest market news with relevance scoring
- I can filter news by symbols, sectors, and sentiment
- I receive breaking news alerts for my watchlist
- I can see sentiment analysis and market impact
- I can access news archives and search functionality

### As a Trader, I want intelligent price alerts
**Acceptance Criteria:**
- I can set multiple alert types (price, volume, technical)
- I can create complex conditional alerts
- I receive alerts through multiple channels (app, email, SMS)
- I can manage and modify my alerts easily
- I can see alert history and performance analytics

### As a Trader, I want advanced charting capabilities
**Acceptance Criteria:**
- I can view multiple chart types and timeframes
- I can apply technical indicators and overlays
- I can save and share chart configurations
- I can analyze historical data with zoom and pan
- I can compare multiple symbols on one chart

## Technical Specification

### Backend Services to Implement

#### 1. Market Scanner Service

**Endpoints:**
```
POST   /api/v1/market/scan
GET    /api/v1/market/scanners
POST   /api/v1/market/scanners
PUT    /api/v1/market/scanners/{scannerId}
DELETE /api/v1/market/scanners/{scannerId}
GET    /api/v1/market/scan/results/{scanId}
POST   /api/v1/market/scan/export
```

**Data Models:**
```java
@Entity
public class MarketScanner {
    private String id;
    private String userId;
    private String name;
    private String description;
    private List<ScanCriteria> criteria;
    private boolean active;
    private LocalDateTime lastRun;
    private int resultCount;
    private LocalDateTime createdAt;
}

@Entity
public class ScanCriteria {
    private String field; // price, volume, marketCap, etc.
    private String operator; // >, <, =, BETWEEN, etc.
    private List<Object> values;
    private String logicalOperator; // AND, OR
}

@Entity
public class ScanResult {
    private String id;
    private String scannerId;
    private String symbol;
    private Map<String, Object> metrics;
    private LocalDateTime timestamp;
    private double relevanceScore;
}
```

**Core Implementation:**
```java
@Service
public class MarketScannerService {
    
    public ScanResult executeScan(MarketScanner scanner) {
        // Apply filtering criteria to market data
        // Calculate technical indicators
        // Score and rank results
        // Cache results for performance
        return scanResult;
    }
    
    public List<ScanResult> getTopMovers(MovementType type, int limit) {
        // Get top gainers, losers, most active
        // Apply real-time data
        return results;
    }
    
    @Scheduled(fixedRate = 30000) // Every 30 seconds
    public void runActiveScans() {
        // Execute all active scanners
        // Send notifications for new matches
        // Update result counts
    }
}
```

#### 2. Economic Calendar Service

**Endpoints:**
```
GET    /api/v1/market/calendar/events
GET    /api/v1/market/calendar/today
GET    /api/v1/market/calendar/week
POST   /api/v1/market/calendar/subscribe
DELETE /api/v1/market/calendar/subscribe/{eventId}
GET    /api/v1/market/calendar/impact-analysis
```

**Data Models:**
```java
@Entity
public class EconomicEvent {
    private String id;
    private String title;
    private String country;
    private String category;
    private ImpactLevel impact;
    private LocalDateTime eventTime;
    private String actual;
    private String forecast;
    private String previous;
    private String description;
    private List<String> affectedCurrencies;
    private List<String> affectedSymbols;
}

@Entity
public class EventSubscription {
    private String userId;
    private String eventId;
    private List<NotificationChannel> channels;
    private int minutesBefore;
    private boolean enabled;
}

public enum ImpactLevel {
    LOW, MEDIUM, HIGH, CRITICAL
}
```

**Core Implementation:**
```java
@Service
public class EconomicCalendarService {
    
    @Scheduled(cron = "0 0 */6 * * *") // Every 6 hours
    public void syncEconomicEvents() {
        // Fetch from external calendar providers
        // Parse and standardize event data
        // Update impact analysis
        economicEventRepository.saveAll(events);
    }
    
    public List<EconomicEvent> getEventsForPeriod(LocalDate start, LocalDate end) {
        // Filter events by date range
        // Apply user preferences
        // Include impact analysis
        return events;
    }
    
    @EventListener
    public void handleEventUpdate(EconomicEvent event) {
        // Send notifications to subscribers
        // Analyze market impact
        // Update related symbols
    }
}
```

#### 3. News Aggregation Service

**Endpoints:**
```
GET    /api/v1/market/news
GET    /api/v1/market/news/breaking
GET    /api/v1/market/news/symbol/{symbol}
GET    /api/v1/market/news/sentiment
POST   /api/v1/market/news/subscribe
GET    /api/v1/market/news/sources
PUT    /api/v1/market/news/preferences
```

**Data Models:**
```java
@Entity
public class NewsArticle {
    private String id;
    private String title;
    private String summary;
    private String content;
    private String url;
    private String source;
    private LocalDateTime publishedAt;
    private List<String> symbols;
    private List<String> sectors;
    private SentimentAnalysis sentiment;
    private double relevanceScore;
    private boolean breaking;
}

@Entity
public class SentimentAnalysis {
    private double positiveScore;
    private double negativeScore;
    private double neutralScore;
    private double overallSentiment;
    private List<String> keywords;
    private double confidenceScore;
}

@Entity
public class NewsSubscription {
    private String userId;
    private List<String> symbols;
    private List<String> sectors;
    private List<String> sources;
    private SentimentFilter sentimentFilter;
    private boolean breakingNewsOnly;
}
```

**Core Implementation:**
```java
@Service
public class NewsAggregationService {
    
    @Scheduled(fixedRate = 60000) // Every minute
    public void aggregateNews() {
        // Fetch from multiple news sources
        // Extract symbols and sectors
        // Perform sentiment analysis
        // Calculate relevance scores
        newsRepository.saveAll(articles);
    }
    
    public SentimentAnalysis analyzeSentiment(String content) {
        // Use NLP library or external service
        // Extract sentiment scores
        // Identify key sentiment indicators
        return sentiment;
    }
    
    public List<NewsArticle> getNewsForSymbol(String symbol, int hours) {
        // Filter news by symbol mentions
        // Sort by relevance and recency
        // Include sentiment analysis
        return articles;
    }
}
```

#### 4. Price Alert Service

**Endpoints:**
```
POST   /api/v1/market/alerts
GET    /api/v1/market/alerts
PUT    /api/v1/market/alerts/{alertId}
DELETE /api/v1/market/alerts/{alertId}
POST   /api/v1/market/alerts/{alertId}/test
GET    /api/v1/market/alerts/history
GET    /api/v1/market/alerts/templates
```

**Data Models:**
```java
@Entity
public class PriceAlert {
    private String id;
    private String userId;
    private String symbol;
    private AlertType type;
    private List<AlertCondition> conditions;
    private List<NotificationChannel> channels;
    private boolean active;
    private int triggerCount;
    private LocalDateTime lastTriggered;
    private LocalDateTime createdAt;
    private LocalDateTime expiresAt;
}

@Entity
public class AlertCondition {
    private String field; // price, volume, change, etc.
    private String operator; // >, <, crosses_above, etc.
    private double value;
    private String timeframe;
    private boolean triggered;
}

public enum AlertType {
    PRICE_TARGET, VOLUME_SPIKE, TECHNICAL_INDICATOR, 
    NEWS_SENTIMENT, ECONOMIC_EVENT, CUSTOM
}
```

**Core Implementation:**
```java
@Service
public class PriceAlertService {
    
    @EventListener
    public void handleMarketDataUpdate(MarketDataUpdate update) {
        // Get alerts for updated symbol
        // Evaluate alert conditions
        // Trigger notifications if conditions met
        List<PriceAlert> alerts = getActiveAlertsForSymbol(update.getSymbol());
        evaluateAlerts(alerts, update);
    }
    
    public boolean evaluateAlertCondition(AlertCondition condition, MarketData data) {
        // Evaluate condition against current data
        // Handle different condition types
        // Support technical indicator conditions
        return conditionMet;
    }
    
    @Async
    public void sendAlertNotification(PriceAlert alert, String message) {
        // Send via configured channels
        // Log alert history
        // Update trigger count
    }
}
```

#### 5. Advanced Chart Data Service

**Endpoints:**
```
GET    /api/v1/market/chart/{symbol}
GET    /api/v1/market/chart/{symbol}/indicators
POST   /api/v1/market/chart/compare
GET    /api/v1/market/chart/historical/{symbol}
POST   /api/v1/market/chart/save-configuration
GET    /api/v1/market/chart/configurations
```

**Data Models:**
```java
@Entity
public class ChartData {
    private String symbol;
    private String timeframe;
    private LocalDateTime timestamp;
    private double open;
    private double high;
    private double low;
    private double close;
    private long volume;
    private Map<String, Double> indicators;
}

@Entity
public class ChartConfiguration {
    private String id;
    private String userId;
    private String name;
    private List<String> symbols;
    private String timeframe;
    private String chartType;
    private List<String> indicators;
    private Map<String, Object> settings;
}

@Entity
public class TechnicalIndicator {
    private String name;
    private String symbol;
    private String timeframe;
    private LocalDateTime timestamp;
    private Map<String, Double> values;
}
```

**Core Implementation:**
```java
@Service
public class ChartDataService {
    
    public List<ChartData> getChartData(String symbol, String timeframe, 
                                       LocalDateTime start, LocalDateTime end) {
        // Fetch OHLCV data
        // Calculate technical indicators
        // Apply timeframe aggregation
        return chartData;
    }
    
    public Map<String, Double> calculateTechnicalIndicators(String symbol, 
                                                           List<String> indicators) {
        // Calculate SMA, EMA, RSI, MACD, etc.
        // Use TA-Lib or similar library
        // Cache calculated values
        return indicatorValues;
    }
    
    public List<ChartData> compareSymbols(List<String> symbols, String timeframe) {
        // Normalize data for comparison
        // Calculate relative performance
        // Return synchronized data
        return comparisonData;
    }
}
```

#### 6. Symbol Master Data Service

**Endpoints:**
```
GET    /api/v1/market/symbols/search
GET    /api/v1/market/symbols/{symbol}
GET    /api/v1/market/symbols/sectors
GET    /api/v1/market/symbols/indices
POST   /api/v1/market/watchlist
GET    /api/v1/market/watchlist
DELETE /api/v1/market/watchlist/{symbol}
```

**Data Models:**
```java
@Entity
public class Symbol {
    private String symbol;
    private String name;
    private String exchange;
    private String sector;
    private String industry;
    private String country;
    private String currency;
    private String type; // STOCK, ETF, INDEX, etc.
    private boolean active;
    private Map<String, Object> metadata;
}

@Entity
public class Watchlist {
    private String userId;
    private String symbol;
    private LocalDateTime addedAt;
    private Map<String, Object> notes;
    private List<String> tags;
}
```

### Frontend Integration Requirements

#### 1. Market Scanner Integration
```typescript
// src/services/marketScannerService.ts
export class MarketScannerService {
    async createScanner(scanner: MarketScanner): Promise<MarketScanner> {
        const response = await apiClient.post('/api/v1/market/scanners', scanner);
        return response.data;
    }
    
    async runScan(scannerId: string): Promise<ScanResult[]> {
        const response = await apiClient.post(`/api/v1/market/scan`, { scannerId });
        return response.data;
    }
    
    async getTopMovers(type: 'gainers' | 'losers' | 'active'): Promise<ScanResult[]> {
        const response = await apiClient.get(`/api/v1/market/scan/top-movers`, { params: { type } });
        return response.data;
    }
}
```

#### 2. Economic Calendar Integration
```typescript
// src/services/economicCalendarService.ts
export class EconomicCalendarService {
    async getEvents(startDate: Date, endDate: Date): Promise<EconomicEvent[]> {
        const response = await apiClient.get('/api/v1/market/calendar/events', {
            params: { startDate: startDate.toISOString(), endDate: endDate.toISOString() }
        });
        return response.data;
    }
    
    async subscribeToEvent(eventId: string, channels: NotificationChannel[]): Promise<void> {
        await apiClient.post('/api/v1/market/calendar/subscribe', { eventId, channels });
    }
}
```

#### 3. News Service Integration
```typescript
// src/services/newsService.ts
export class NewsService {
    async getMarketNews(filters: NewsFilters): Promise<NewsArticle[]> {
        const response = await apiClient.get('/api/v1/market/news', { params: filters });
        return response.data;
    }
    
    async getSymbolNews(symbol: string, hours: number = 24): Promise<NewsArticle[]> {
        const response = await apiClient.get(`/api/v1/market/news/symbol/${symbol}`, { params: { hours } });
        return response.data;
    }
    
    async subscribeToNews(subscription: NewsSubscription): Promise<void> {
        await apiClient.post('/api/v1/market/news/subscribe', subscription);
    }
}
```

#### 4. Price Alert Integration
```typescript
// src/services/priceAlertService.ts
export class PriceAlertService {
    async createAlert(alert: PriceAlert): Promise<PriceAlert> {
        const response = await apiClient.post('/api/v1/market/alerts', alert);
        return response.data;
    }
    
    async getAlerts(): Promise<PriceAlert[]> {
        const response = await apiClient.get('/api/v1/market/alerts');
        return response.data;
    }
    
    async testAlert(alertId: string): Promise<boolean> {
        const response = await apiClient.post(`/api/v1/market/alerts/${alertId}/test`);
        return response.data.success;
    }
}
```

#### 5. WebSocket Integration for Real-time Data
```typescript
// src/services/marketDataWebSocket.ts
export class MarketDataWebSocketService {
    private ws: WebSocket;
    private subscriptions: Set<string> = new Set();
    
    connect(): void {
        this.ws = new WebSocket(`${WS_BASE_URL}/market-data`);
        
        this.ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleMarketDataUpdate(data);
        };
    }
    
    subscribe(symbol: string): void {
        if (!this.subscriptions.has(symbol)) {
            this.ws.send(JSON.stringify({ action: 'subscribe', symbol }));
            this.subscriptions.add(symbol);
        }
    }
    
    private handleMarketDataUpdate(data: MarketDataUpdate): void {
        // Update component state
        // Trigger alert evaluations
        // Update charts and displays
    }
}
```

### Database Schema Extensions

```sql
-- Market Scanners
CREATE TABLE market_scanners (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    criteria JSONB NOT NULL,
    active BOOLEAN DEFAULT true,
    last_run TIMESTAMP,
    result_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Economic Events
CREATE TABLE economic_events (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(500) NOT NULL,
    country VARCHAR(10),
    category VARCHAR(100),
    impact VARCHAR(20),
    event_time TIMESTAMP NOT NULL,
    actual VARCHAR(100),
    forecast VARCHAR(100),
    previous VARCHAR(100),
    description TEXT,
    affected_currencies TEXT[],
    affected_symbols TEXT[],
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- News Articles
CREATE TABLE news_articles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(1000) NOT NULL,
    summary TEXT,
    content TEXT,
    url VARCHAR(2000),
    source VARCHAR(100),
    published_at TIMESTAMP NOT NULL,
    symbols TEXT[],
    sectors TEXT[],
    sentiment JSONB,
    relevance_score DECIMAL(5,4),
    breaking BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Price Alerts
CREATE TABLE price_alerts (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    alert_type VARCHAR(50) NOT NULL,
    conditions JSONB NOT NULL,
    channels JSONB NOT NULL,
    active BOOLEAN DEFAULT true,
    trigger_count INTEGER DEFAULT 0,
    last_triggered TIMESTAMP,
    expires_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Chart Configurations
CREATE TABLE chart_configurations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id VARCHAR(50) NOT NULL,
    name VARCHAR(255) NOT NULL,
    symbols TEXT[],
    timeframe VARCHAR(10),
    chart_type VARCHAR(20),
    indicators TEXT[],
    settings JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- User Watchlists
CREATE TABLE user_watchlists (
    user_id VARCHAR(50) NOT NULL,
    symbol VARCHAR(20) NOT NULL,
    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    notes JSONB,
    tags TEXT[],
    PRIMARY KEY (user_id, symbol)
);

-- Indexes for performance
CREATE INDEX idx_market_scanners_user_id ON market_scanners(user_id);
CREATE INDEX idx_economic_events_time ON economic_events(event_time);
CREATE INDEX idx_news_articles_published ON news_articles(published_at);
CREATE INDEX idx_news_articles_symbols ON news_articles USING GIN(symbols);
CREATE INDEX idx_price_alerts_user_symbol ON price_alerts(user_id, symbol);
CREATE INDEX idx_price_alerts_active ON price_alerts(active);
CREATE INDEX idx_watchlists_user_id ON user_watchlists(user_id);
```

## Testing Requirements

### Unit Tests
- Market scanning algorithm accuracy
- Economic event parsing and normalization
- News sentiment analysis accuracy
- Price alert condition evaluation
- Technical indicator calculations

### Integration Tests
- End-to-end market scanning workflow
- Economic calendar event notifications
- News aggregation and filtering
- Price alert triggering and notifications
- WebSocket real-time data flow

### Performance Tests
- Market scan execution time (<5 seconds)
- Real-time data processing latency (<100ms)
- Chart data retrieval speed (<1 second)
- Alert evaluation performance (<50ms per alert)

## Definition of Done

- [ ] All backend services implemented and tested
- [ ] Frontend components integrated with real APIs
- [ ] WebSocket connections established and working
- [ ] Database schema migrated and optimized
- [ ] Real-time data flows functioning
- [ ] Performance benchmarks met
- [ ] Error handling and fallback mechanisms implemented
- [ ] Documentation updated
- [ ] Security review completed

## Dependencies

### Technical Dependencies
- Market data provider API integration
- News aggregation service setup
- Economic calendar data source
- Technical analysis library (TA-Lib)
- WebSocket infrastructure
- Notification service for alerts

### Story Dependencies
- Story 2.1.1 (Authentication service for user-specific features)
- Market data provider contracts
- Real-time data feed setup

## Success Metrics

### Technical Metrics
- Market scan execution time <5 seconds
- Real-time data latency <100ms
- Alert accuracy >99%
- Chart loading time <1 second
- WebSocket connection stability >99.9%

### Business Metrics
- User engagement with market tools increase by 60%
- Time spent on platform increase by 40%
- Alert usage adoption >70%
- Market analysis feature satisfaction >4.5/5

## Implementation Plan

### Week 1: Core Market Data Services
- Implement market scanner service
- Set up symbol master data service
- Create watchlist management

### Week 2: Real-time Integration
- Implement WebSocket infrastructure
- Add price alert service
- Create chart data service

### Week 3: News & Calendar Services
- Implement news aggregation service
- Add economic calendar service
- Set up notification systems

### Week 4: Frontend Integration & Testing
- Integrate all frontend components
- Complete testing and optimization
- Performance tuning and deployment